var tipuesearch = {"pages": [{'title': '成員', 'text': '組長: \n 40723104 \xa0 \xa0 \xa0 \xa0\xa0 • 倉儲 \xa0 \xa0 \xa0 \xa0\xa0 • 網站 \n 組員: \n 40423208\xa0 \xa0 \xa0 \xa0  • 倉儲 \xa0 \xa0 \xa0 \xa0\xa0 • 網站 \n 40523142\xa0 \xa0 \xa0 \xa0 \xa0 • 倉儲 \xa0 \xa0 \xa0 \xa0 \xa0 • 網站 \n 40723106\xa0 \xa0 \xa0 \xa0 \xa0 • 倉儲 \xa0 \xa0 \xa0 \xa0 \xa0 • 網站 \n 40723108\xa0 \xa0 \xa0 \xa0 \xa0 • 倉儲 \xa0 \xa0 \xa0 \xa0 \xa0 • 網站 \n 40723111\xa0 \xa0 \xa0 \xa0 \xa0 • 倉儲 \xa0 \xa0 \xa0 \xa0 \xa0 • 網站 \n 40723121\xa0 \xa0 \xa0 \xa0 \xa0 • 倉儲 \xa0 \xa0 \xa0 \xa0 \xa0 • 網站 \n 40723123 \xa0 \xa0 \xa0 \xa0 \xa0 • 倉儲 \xa0 \xa0 \xa0 \xa0 \xa0 • 網站 \n 40723126\xa0 \xa0 \xa0\xa0 \xa0\xa0 • 倉儲 \xa0 \xa0 \xa0 \xa0 \xa0 • 網站 \n 40723128 \xa0 \xa0 \xa0 \xa0 \xa0 • 倉儲 \xa0 \xa0 \xa0\xa0 \xa0 • 網站 \n 40723130 \xa0 \xa0 \xa0\xa0 \xa0 • 倉儲 \xa0 \xa0 \xa0 \xa0 \xa0 • 網站 \n 40723133 \xa0 \xa0 \xa0\xa0 \xa0 • 倉儲 \xa0 \xa0 \xa0 \xa0 \xa0 • 網站 \n 利用 cmsimde 建立靜態網誌方法: \n 1. 在 github 建立倉儲, git clone 到近端 \n 2. 參考\xa0 https://github.com/mdecourse/newcms , 加入除了 cmsimde 目錄外的所有內容 \n 以 git submodule add\xa0 https://github.com/mdecourse/cmsimde \xa0cmsimde \n 建立 cmsimde 目錄, 並從 github 取下子模組內容. \n 3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器. \n 動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端. \n 4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行: \n git clone --recurse-submodules  https://github.com/mdecourse/newcms.git \n <<<<<<< HEAD \n', 'tags': '', 'url': '成員.html'}, {'title': 'Develop', 'text': 'https://github.com/mdecourse/cmsimde \xa0的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443\xa0就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容. \n cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版. \n init.py 位於\xa0 up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數. \n', 'tags': '', 'url': 'Develop.html'}, {'title': 'NX12翻譯', 'text': '', 'tags': '', 'url': 'NX12翻譯.html'}, {'title': '前言', 'text': 'NX 是世界上最先進的CAD/CAM/CAE集成產品之一Simmen PLM software 所開發，可開發之產品非常廣泛，NX簡化複雜的產品並加快了產品推向市場的過程，為企業提供了一個巨大的價值。 NX結合了許多科學原理、概念設計、3D建模、文檔、工程分析、圖形模擬和並行工程。擁有強大的混和建模過能，除了建模標準零件也可以用於設計複雜的形狀如:機翼，實體和去面建模技術讓他成為強大的工具集。 這本教學指南將一步步教使用者使用NX12，目標是以前沒使用過NX的使用者，但是使用舊版本NX的用戶可以學習新的介面和功能，用戶將從NX12開始到創建模具各種功能的模型設計指導應用程序，每一章都會透過對話框和截圖來說明，這些組件隨後用於裝配建模，加工和有限元素分析。組件文件也可以在線下載和使用。我們先發布了Unigraphics 18教程，隨後針對NX 2進行了更新，隨後更新了NX 3，NX 5，NX 7，NX 9和NX10。此內容進一步更新了NX 12。\\ \n 翻譯40723123 \n', 'tags': '', 'url': '前言.html'}, {'title': '第一章', 'text': '現代製造環境的特徵在於交付範式品種不斷增加的產品，在不斷增加的情況下，小批量和高質量全球競爭。除非引入新的行業，否則它們無法在全球競爭中生存產品質量更高，成本更低，交付週期更短。有激烈國際競爭和技術工人的減少。隨著變化計算能力和更廣泛的設計和生產軟件工具可用性，工程師們現在使用計算機輔助設計CAD、計算機輔助製造CAM、計算機輔助工程CAE系統可使其設計和生產過程自動化。這些現在，技術每天都用於各種不同的工程任務。下面是一個簡短的產品期間如何使用CAD，CAM和CAE技術的說明實現過程。 \n 1.1產品實現過程 \n 產品實現過程可以大致分為兩個階段：設計和製造。設計過程從識別新客戶需求和要設計的變量開始改進，由營銷人員從顧客。一旦收集了相關的設計信息，便制定了設計規範。進行可行性研究並提供相關設計信息以及詳細的設計和分析執行。詳細設計包括設計概念化，預期產品圖紙，草圖和幾何建模。分析包括壓力分析，干擾檢查，運動學分析，質量特性計算和公差分析以及設計優化。從這些活動中獲得的結果的質量與分析的質量以及進行分析的工具。 製造過程從生產開始的車間活動開始規劃，使用設計過程圖並以實際產品結束。處理規劃包括生產計劃，材料採購和機器等活動選擇。有各種各樣的任務，例如購買新工具，NC編程和質量在生產過程的各個階段進行檢查。流程計劃包括對產品製造中使用的所有流程的規劃。通過質量控制檢查的零件經功能測試組裝，包裝，貼標籤並運送給客戶。 \n 表示產品實現過程的圖（Ibrahim Zeid撰寫的Mastering CAD / CAM，麥格勞·希爾（McGraw Hill，2005）。圖 \n \n 1.2 CAD / CAM開發的簡要歷史 \n 當前的CAD / CAM技術的起源可以追溯到文明的開始埃及的工程師認可圖形通信。正交投影實踐今天是在1800年代發明的CAD / CAM系統的真正開發始於1950年代。 CAD / CAM在上個世紀經歷了四個主要的發展階段。 1950年代被稱為交互式計算機圖形時代。麻省理工學院伺服機構實驗室在三軸銑床上演示了數控（NC）的概念。發展歷程在這個時代，由於當時計算機的缺點而放慢了速度。1950年代後期開始開發自動編程工具（APT），並探索通用汽車公司互動圖形的潛力。 1960年代是交互式計算機圖形學最關鍵的研究時期。伊万·薩瑟蘭開發了一個畫板系統，該系統演示了創建圖紙的可能性以及陰極射線管（CRT）上的物體交互。CAD一詞開始出現“設計”一詞超出了基本的製圖概念。通用汽車宣布了他們的DAC-1系統和Bell Technologies推出了GRAPHIC 1遠程顯示系統。 1970年代，計算機圖形學的前十年研究開始富有成果，並實現了交互式計算機圖形在提高生產力方面的潛力按行業，政府和學術界。 1970年代被描述為計算機的黃金時代起草和特別儀器設計應用程序的開始。國家計算機圖形協會（NCGA）成立，並且初始圖形交換規範（IGES）開始了。 在1980年代，新的理論和算法得到了發展，並且將各種設計要素整合在一起並發展了製造業。主要的研發重點是擴大CAD / CAM系統超越了三維幾何設計，提供了更多的工程設計應用程序。 當前的CAD / CAM開發側重於高效，快速的集成和自動化設計和製造的各種要素以及新算法的開發。有許多商業化的CAD / CAM軟件包可用於用戶友好的直接使用而且非常熟練。 \n 以下是當前市場中的一些商業軟件包。 \n Solid Edge, AutoCAD, Inventor and TurboCAD是一些負擔得起的CAD軟件系統。 \n NX, Pro-E, CATIA and SolidWorks是高端的建模和設計軟件更昂貴但功能更強大的系統。這些軟件系統還具有計算機輔助的製造和工程分析功能。 \n Onshape and Fusion 360是基於 CAD software提供CAD用戶的瀏覽器。 \n ANSYS, ABAQUS, NASTRAN and COMSOL 是主要用於CAE的軟件包目的。 \n 1.3 定義CAD/CAM/CAE \n 1.3.1 Computer Aided Design – CAD CAD是與使用計算機系統協助創建，修改，分析和優化設計。任何體現計算機圖形的計算機程序可以對在設計過程中促進工程功能的應用程序進行分類作為CAD軟件。 \n CAD的最基本作用是定義設計的幾何形狀-機械零件，產品組件，建築結構，電子電路，建築物佈局等。最偉大的CAD系統的好處是可以節省大量時間並減少由否則，每次需要時，都必須從頭開始重新定義設計的幾何形狀。 \n 1.3.2 Computer Aided Manufacturing – CAM \n CAM技術涉及計劃，管理和控制製造的計算機系統通過計算機界面與工廠的生產資源進行操作。 CAM最重要的領域之一是數控（NC）。這是使用的技巧用於控制機床的程序化指令，該機床可以進行原始的切削，銑削，磨削，沖壓或車削庫存成成品。 CAM的另一個重要功能是在機器人編程中。流程計劃也是計算機自動化的目標。 \n 1.3.3 Computer Aided Engineering – CAE \n CAE技術使用計算機系統來分析CAD創建的產品的功能，允許設計師模擬和研究產品的行為，以便設計完善和優化。 CAE工具可用於許多不同類型的分析。例如運動學分析程序可用於確定機構中的運動路徑和連桿速度。動態分析程序可用於確定複雜結構中的載荷和位移裝配，例如汽車。最受歡迎的分析方法之一是使用有限元素方法（FEM）。該方法可用於確定應力，變形，傳熱，磁場分佈，流體流動以及其他通常很難解決的連續磁場問題用其他方法解決。 \n 1.4。本教程的範圍 \n 本教程是為有興趣學習如何使用NX 12的學生和工程師編寫的用於設計機械零件和組件。學習使用NX 12也將很有價值學習如何使用其他CAD系統，例如PRO-E和CATIA。本教程提供了學習NX 12的系統方法。 \n 第2章介紹了從開始會話到熟悉NX的NX 12基本知識。通過練習基本功能（如打印，保存和退出）來佈局12。它還給出了簡短的描述坐標系，圖層，各種工具箱和其他重要命令在後面的章節中使用。 \n 第3章介紹了素描的概念。它描述瞭如何創建草圖並給出幾何和尺寸約束。從今天開始，本章非常重要組件的幾何形狀非常複雜，僅憑基本特徵很難建模。零件的實際設計和建模始於第4章。它描述了不同的功能例如參考特徵，掃描特徵和原始特徵，以及如何使用這些特徵創建設計。對特徵執行各種特徵操作。 \n 您將在第5章中學習如何從零件模型創建工程圖。在本章中，我們將通過添加視圖，標註零件圖紙尺寸來演示如何創建圖紙，以及修改圖形中的各種屬性，例如文本大小，箭頭大小和公差。 \n 第6章介紹了裝配建模的概念及其術語。它描述了TopDown建模和Bottom-Up建模。我們將使用自下而上的模型進行組裝組件變成產品。 \n 第7章介紹了自由格式建模。曲線和平滑曲面的建模方法將被演示。 \n 第8章概述了NX 12中提供的Design Simulations的簡要介紹。有限元分析。 \n 第9章將是在製造中實施設計模型的實時經驗加工環境。本章介紹工具的生成，驗證和模擬 創建CNC（計算機數字代碼）以從多軸生產設計零件的路徑甚至先進的CNC機器。 \n 每章中使用的示例和練習問題都經過精心設計，以使它們最終得以應用組裝在本章中。由於這項獨特的功能，您應該保存所有的模型在每一章中都有創建。 \n 翻譯40723123 \n ======= \n', 'tags': '', 'url': '第一章.html'}, {'title': '第二章', 'text': '第 2 章 - 入門 \n 首先開始 NX 12 會話。 本章將提供使用所需的基礎知識 \n 任何 CAD / CAM 軟體包。 您將學習開始，理解和使用 \n 用於建模，製圖等的 NX 12 軟體包。它包含五個小節： a ）打開 NX 12 \n 會話， b ）打印，保存和關閉零件文件， c ）熟悉 NX 12 用戶 \n 界面 d ）使用圖層和 e ）了解重要的命令和對話框。 \n 2.1 啟動 NX 12 會話並打開文件 \n 2.1.1 開始 NX 12 會話 \n 在 Windows 桌面屏幕上，單擊開始→程序列表→ Siemens NX 12 → NX 12 \n \n NX 12 主螢幕將打開。 這是 NX 12 軟體的閘道器。 \xa0 NX 12 空白 \n 屏幕看起來如下圖所示。 屏幕上將顯示一些提示，關於 \n 當前版本的特殊功能。 閘道器還具有標準工具欄，它將 \n 允許您創建一個新文件或打開一個現有文件。 在“閘道器”屏幕的左側，有 \n 是一個稱為“資源欄”的工具欄，它具有與不同模塊相關的菜單，並且能夠 \n 定義和更改軟體的角色，查看軟體使用的歷史記錄等。 這會 \n 將在本章稍後詳細解釋。 \n \n 2.1.2 打開一個新文件 \n 首先，我們學習如何在 NX 12 中打開新零件文件。要創建新文件，請執行以下三個操作選項。 \n 單擊螢幕頂端的“新建”按鈕 \n 瀏覽屏幕左上方的 File （文件）下拉菜單，然後單擊 New （新建）。 \n 或按 <Ctrl> + N \n 這將打開一個新會話，詢問要創建的新文件的類型，名稱和位置。 \n NX 12 中有多種文件類型，可從位於以下位置的“模板”對話框中選擇 \n 窗口的中心。 所選文件的屬性顯示在“預覽”下 \n 右邊。 由於我們要在建模環境中工作並創建新零件，因此僅 \n 指定工作環境的單位（英寸或毫米）以及名稱和位置 \n 文件。 默認單位是毫米。 \n 輸入文件的適當名稱和位置，然後點擊“確定”。 \n \n 2.1.3 打開零件文件 \n 有幾種打開現有文件的方法。 \n 點擊螢幕頂端的打開或打開最近的零件按鈕要么 \n 瀏覽屏幕左上方的 File （文件）下拉菜單，然後單擊 Open （打開）。 \n 或按 <Ctrl> + O 將顯示“打開零件文件”對話框。 您可以在右側查看文件預覽 \n 窗口。 您可以通過取消單擊“預覽”按鈕前面的框來禁用“預覽”點擊取消退出窗口 \n \n 2.2列印，保存和關閉文件 \n 2.2.1列 印 NX 12 圖像要從當前顯示器打印圖像，點擊文件→打印\xa0 \xa0 \n 下圖顯示了“打印”對話框。 這裡， \n 您可以選擇要使用的打印機或指定編號 \n 打印份數，紙張尺寸等。 \n 您還可以為所有三個選擇比例尺寸。 \n 您也可以選擇 \n 通過單擊來打印，即線框實體模型 \n 輸出下拉菜單，如右圖所示 \n 單擊取消退出窗口 \n 2.2.2 保存零件文件 \n 必須經常保存工作。 如果 \n 由於某些原因， NX 12 會關閉，而零件沒有 \n 儲存後，所有工作都會丟失。 要儲存零件文件，點擊文件→儲存 \n 有五個選項可儲存文件： \n 儲存：此選項將使用 \n 與創建零件文件時給定的名稱相同。 \n 僅保存工作零件：此選項將僅保存螢幕上的活動部分。 \n 另存為：此選項允許您使用其他名稱和 / 或類型將零件保存在螢幕上。 \n 默認類型是 .prt 。 但是，您可以將文件另存為 IGES （ .igs ）， STEP 203 （ .stp ）， STEP 214 （ .step ）， AutoCAD DXF （ .dxf ）， AutoCAD DWG （ .dwg ）， CATIA 模型（ .model ）和 CATIA V5 （ .catpart ）。 \n 全部保存：此選項將保存所有打開的零件文件及其現有名稱。 \n 保存書籤：此選項會將螢幕截圖和當前模型的上下文保存在螢幕上 \n 作為 .JPEG 文件和書籤。 \n \n 2.2.3 關閉零件文件 \n 您可以選擇關閉零件在螢幕上可看見點擊文件→關閉 \n 如果您關閉文件，該文件將從以下位置清除 \n 工作記憶和任何更改不保存將丟失。 因此，請記住 \n 選擇“保存並關閉”，“另存並關閉”， \n 保存所有並關閉或保存所有並退出。 在在前三個選項的情況下， \n 已選擇，否則所有零件都將關閉，但 NX 12 會話繼續運行。 \n \n 2.2.4 退出 NX 12 會話 \n 點擊文件→退出 \n \n 如果您打開了文件並在未保存的情況下進行了更改，則消息將詢問您是否 \n 真的想退出。選擇否，保存文件，然後退出 \n . NX 12 接口 \n 通過使用不同的圖標， NX 12 的用戶界面變得非常簡單。大部分的 \n 可以通過在屏幕上導航滑鼠並單擊圖標來執行命令。 \n 鍵盤輸入主要限於輸入值和命名文件。 \n 2.3.1 滑鼠功能 \n 2.3.1.1 滑鼠左鍵（ MB1 ） \n 滑鼠左鍵（在 NX 中稱為鼠標鍵 1 （ MB1 ））用於選擇圖標，菜單， \n 和圖形屏幕上的其他實體。 在任何功能上雙擊 MB1 都會自動 \n 打開“編輯對話框”。 單擊對像上的 MB1 ，使用戶可以快速訪問 \n 如下所示的幾個選項。 這些選項將在下一章中討論。 \n \n 2.3.1.2 滑鼠中鍵（ MB2 ） \n 滑鼠中鍵（ MB2 ）或滾動按鈕用於通過按下來旋轉對象， \n 按住並拖動。 模型也可以繞單個軸旋轉。 繞軸旋轉 \n 垂直於屏幕，將滑鼠指針放在圖形屏幕的右邊緣附近，然後 \n 旋轉。 同樣，對於垂直軸和垂直於屏幕的軸，單擊底部 \n 屏幕的上邊緣和上邊緣分別旋轉。 如果您同時按住 MB2 \n 位置幾秒鐘，它將固定旋轉點（出現橙色圓圈符號） \n 您可以在對象周圍拖動以查看。 \n 如果是滾動按鈕，則可以通過滾動對象來放大和縮小。 單擊 MB2 將 \n 如果打開了任何彈出窗口或對話框，還可以執行“確定”命令 \n \n 2.3.1.3 鼠標右鍵（ MB3 ） \n MB3 或滑鼠右鍵用於訪問用戶界面彈出窗口菜單。 您可以訪問後續彈出的選項取決於選擇模式和應用。 的下圖顯示在草圖中應用。單擊 MB3 時選擇功能將提供選項與該功能有關（對象 / 動作菜單）。 \n \n 單擊 MB3 並按住按鈕將在功能周圍顯示一組圖標。這些圖標具有可應用於功能的可能命令 \n \n 2.3.1.4 按鈕組合 \n 放大 / 縮小： \n 同時按住 MB1 和 MB2 並拖動 \n 按住鍵盤上的 <Ctrl> 按鈕，然後按住並拖動 MB2 \n \n 同時按住 MB2 和 MB3 並拖動 \n 要按住鍵盤上的 <Shift> 按鈕並按住 MB2 \n \n 菜單快捷方式： \n ➢按住 <Ctrl> + <Shift> 和 MB1 ， MB2 和 MB3 可以看到功能的快捷方式， \n 直接草圖組和同步建模組 \n 2.3.2 NX 12 網關 \n 下圖顯示了打開文件時 NX 12 窗口的典型佈局。 這是 NX 12 的閘道器可以選擇要處理的任何模塊，例如建模，必須注意這些工具欄可能不完全在同一位置 \n 如下圖所示。 工具欄可以放置在屏幕上的任何位置或位置。查找相同的圖標集。 \n \n 2.3.2.1 功能區欄 \n 功能區界面使用戶能夠輕鬆訪問不同的命令，而無縮小圖形窗口區域。命令組織在不同選項卡下的功能區欄中和組，以便於識別和訪問。 \n 例如，在上圖所示的功能區欄中，我們具有“開始”，“曲線”等選項。在裡面 \n 主頁選項卡中，我們具有直接草圖，特徵，同步建模和曲面組。 並且在每個 \n 組中，我們有一組功能強大的命令。 \n 2.3.2.2 快速訪問工具欄 \n 快速訪問工具欄具有最常用的按鈕（保存，復原，重做，剪切，複製，貼上和 \n 最近的命令）以加快建模過程。 您可以輕鬆地將這些按鈕自定義為如下圖所示 \n \n 2.3.2.3 命令查找器 \n 如果您不知道在哪裡可以找到命令，請使用“命令查找器”。 假設我們忘記了 \n 樣式掃描的位置。 \n 在命令查找器中輸入掃描將游標懸停在樣式掃描上 \n NX 將顯示命令路徑：菜單→插入→掃描→樣式化掃描 \n 或是在命令查找器中輸入掃描在“命令查找器”窗口中單擊樣式化掃描 \n \n 2.3.2.4 上邊界 \n 頂部邊框中最重要的按鈕是菜單按鈕。 大部分功能菜單中提供了該軟件的版本。 選擇欄顯示選擇選項。 這些選項包括用於選擇特徵的“過濾器”，“零部件 / 裝配體”和“捕捉點”。 “視圖”選項中的常用按鈕也顯示在“頂部邊框”中。 \n 2.3.2.5 資源欄 \n 資源欄使用很少的用戶界面就可以在一處顯示多個頁面的圖標空間。 \xa0 NX 12 將所有導航器窗口（裝配體，約束和零件）放置在資源欄中，以及重用庫， HD3D 工具，網頁瀏覽器，歷史記錄面板， Process Studio ，製造嚮導，角色和系統場景。 兩個最重要的寡婦是解釋如下 \n 零件導航器 \n 單擊零件瀏覽器圖標，第三個資源欄頂部的圖標 \n \n 零件導航器提供可視化表示要素中的父子關係以樹型格式在單獨的窗口中工作。它顯示了在此期間使用的所有原語，實體造型。 它允許您執行各種編輯這些功能上的操作。 例如，您可以使用零件導航器來抑製或取消抑制功能或更改其參數或位置尺寸。 刪除綠色的勾號將“取消”功能。 該軟體會給警告如果父子關係被打破取消任何特定功能。 \n 零件瀏覽器可用於所有 NX 應用程序而不僅僅是建模。 但是，您只能執行功能編輯操作當您在“建模”模塊中時。 在零件瀏覽器中編輯特徵將自動更新模型。 特徵編輯將在後面討論。 \n 歷史 \n 單擊歷史記錄圖標，資源欄頂部的第七個圖標歷史選項板提供對最近打開的文件或其他選項板條目的快速訪問。 有可能用於重新下載最近處理過的零件或重複添加一小組調色板項目的模型。歷史選項板會記住上一次使用的選項板選項以及會話的狀態當它關閉時。 \xa0 NX 存儲已加載到會話中的選板並將其還原到 \n 下屆會議。 移動零件時，系統不會清除歷史記錄選板。要重用零件，請將其從歷史記錄中拖放調色板到圖形窗口。 要重新加載零件，單擊已保存的會話書籤。 \n 2.3.2.6 提示線 \n 提示行顯示提示消息，指示接下來需要採取的行動。 在 \xa0 - \xa0 的右邊提示行，狀態行位於顯示有關當前選項的消息或最近完成的功能。進度表顯示在提示行中 \n 當系統執行耗時的操作，例如下載大型裝配體。 的儀表顯示的操作百分比完成了。 操作完成後，系統顯示下一個適當的提示。 \n \n 2.3.3 幾何選擇 \n 您可以過濾選擇方法，這有助於在緊密的簇中輕鬆選擇幾何。 在此外，您可以執行任何功能 NX 12 智能提供的操作選項取決於所選實體。 項目的選擇可以基於實體的程度，例如選擇幾何實體，特徵和零部件。 選擇方法可以選擇 \n 選擇選擇工具欄中的圖標之一。 \n 2.3.3.1 特徵選擇 \n 點任何圖標，可以選擇零件文件中的特徵。 它不會選擇基本實體，例如邊緣面等。選定的特徵也可以應用於一部分或整個根據要求組裝。 \n \n 除此之外，可以進一步縮小特徵的過濾範圍在下拉菜單中選擇所需選項之一，如數字。 例如，選擇“曲線”將僅高亮顯示屏幕。 默認值為“無選擇過濾器”。 \n \n 2.3.3.2 常規對象選擇 \n 將鼠標光標導航到實體附近，直到用突出顯示它為止洋紅色，然後單擊滑鼠左鍵以選擇任何幾何實體，功能或組件。 \n \n 如果要選擇隱藏在顯示的幾何圖形後面的實體，將滑鼠光標放在屏幕上該區域附近，以便光標球佔據了投影在屏幕上的隱藏幾何的一部分屏幕。幾秒鐘後，球形光標變為加號如圖所示。單擊鼠標左鍵（ MB1 ）以獲取選擇確認對話框，如下圖如下。這個 QuickPick 菜單由實體列表組成捕獲在光標的球內的實體按以下升序排列實體的程度。例如，邊和頂點指定為較低給出實心面的數字更高的數字。通過移動光標顯示的數字， NX 12 將用洋紅色突出顯示屏幕上的相應實體。 \n \xa0 \n 2.3.4 用戶首選項 \n 在菜單按鈕（位於主窗口左上角）中選擇首選項以查找各種可用選項用戶首選項用於定義以下內容的顯示參數：新對象，名稱，佈局和視圖。 您可以設置圖層，創建對象的顏色，字體和寬度。 您也可以設計佈局和視圖，控制對象和視圖的顯示名稱和邊框，更改選擇球的大小，指定選擇矩形方法，設置鏈接公差和方法，以及設計和激活網格。 改變你使用“首選項”菜單進行覆蓋 \n 客戶默認使用相同功能 \n \n 2.3.4.1 用戶界面 \n 選擇首選項→用戶界面以找到對話框中的選項用戶界面選項可自定義 NX 的工作方式以及與您設置的規范進行交互。 您可以控制主窗口的位置，大小和可見性狀態，圖形顯示和信息窗口。 您可以設置系統用於的小數位數（精度）信息中顯示的輸入文本字段和數據窗口。 您還可以為文件指定完整或小型對話框選擇。 您還可以設置宏選項並啟用撤消操作的確認對話框。 \n \n 佈局選項卡允許您選擇用戶界面環境 \n “觸摸”選項卡使您可以使用觸摸屏 \n 通過“選項”選項卡，您可以設置精度級別（在“信息”中窗口） \n 工具中的日誌選項卡允許您使用多種編程語言 \n 工具中的“巨集”選項卡允許您設置顯示動畫時的暫停 \n \n \n 2.3.4.2 可視化 \n ➢選擇首選項→可視化以找到對話框中的選項 \n \n 該對話框控制會影響顯示的屬性圖形窗口。一些屬性與零件或零件的特定視圖的設置這些屬性保存在零件文件中。 對於其中許多屬性，當創建新零件或視圖時，該設置初始化為客戶默認文件。 其他屬性與會話和適用於會話中的所有部分。一些設置這些屬性在每個會話中保存在註冊表。 對於某些會話屬性，設置可以為初始化為客戶默認值默認文件的一個環境變量。 \n ➢選擇“首選項”→“調色板”以查找對話框中的選項 \n ➢點擊首選項→在背景獲取另一個彈出對話框。 \n \n 你可以改變您想要的背景色背景色是指圖形窗口的背景。 \xa0 NX 支持所有顯示模式的漸變背景。 您可以選擇陰影或線框的背景顏色顯示。 背景可以是純色或漸變色。所有背景顏色的有效選項是 0 到 255 。 \n 您可以更改並觀察顏色和物體的半透明 \n ➢單擊首選項→對象 \n \n 這將彈出一個對話框窗口“對象首選項”。您也可以將此設置應用於以下對象的單個實體。 例如，您可以單擊任何特定的實體的表面並應用“顯示”設置。 \n 2.3.5 應用 \n 可以使用“文件”選項打開應用程序位於主窗口的左上角或功能區欄上方的“應用程序”選項卡。 您可以選擇要運行的應用程序類型。對於例如，您可以選擇“建模”，“製圖”組裝，如圖所示。 打開您的計算機時啟動的默認應用程序文件或開始新文件的是 Modeling 。 接下來，我們將介紹其中一些應用程序章節。 \n \n 2.4 層 \n 圖層用於將對象存儲在文件中，並像容器一樣工作以將對象收集到文件中。有條理和一致的方式。 與簡單的視覺工具（例如顯示和隱藏）不同，圖層提供一種永久的方式來組織和管理文件中對象的可見性和選擇性。 \n 2.4.1 圖層控制 \n 使用 NX 12 ，您可以使用“圖層”控制對像是可見還是可選。 一層是 NX 12 中所有對象必須具有的系統定義的屬性，例如顏色，字體和寬度。 NX 12 那裏有 256 個可用層，其中之一始終是工作層。 \xa0 256 個圖層中的任何一個都可以被分配給四種狀態分類之一 \n \n 工作 \n 可選擇的 \n 僅可見 \n 不可見 \n \n 工作層是在其上創建對象的層，並且始終可見並且可以選擇，而它仍然是工作層。啟動新零件文件時，第 1 層是默認的工作層。當工作層更改為另一種類型的層時，先前的工作層將自動變為“可選”，並且可以然後被分配為“僅可見”或“不可見”狀態 \n 可以在一層上的對像數量不受限制。 您可以自由選擇要創建的圖層 \n 對象及其所在層的狀態。 \n 要將狀態分配給一個或多個圖層， \n ➢選擇查看→圖層設置 \n \n 但是，應該注意的是，在關於文件之間層將有利於保持一致性。 \n 2.4.2 分層命令 \n 我們將按照簡單的步驟來練習“層”中的命令。 首先，我們將創建兩個對象 \n （固體）按如下方法處理。實體模型的詳細信息將在下一部分討論章節。 我們在此處繪製的實體僅在本章中用於實踐。 \n ➢選擇文件→新建 \n 命名文件並選擇要在其中保存文件的文件夾。確保在下拉菜單中選擇單位為毫米。 選擇文件類型作為模型 \n ➢選擇菜單→插入→設計特徵→圓錐 \n \n \n ➢在類型下選擇直徑和高度 \n ➢點擊確定 \n ➢ 右鍵單擊屏幕，然後選擇“右側視圖” 三座標 \n ➢右鍵單擊屏幕，然後選擇“渲染”。樣式→陰影 \n 您將能夠看到類似於圖片的實心圓錐在右邊。 \n 讓我們練習一些圖層命令。 \n ➢選擇查看→移動到圖層，系統將要求您選擇一個對象 \n ➢將光標移到圓錐上並單擊，使其突出顯示 \n ➢點擊確定 \n \n 在窗口頂部的“目標層”或“類別”空間中，鍵入 25 並單擊“確定”。 \n 圓錐現在已經到達第 25 層。 它不再是在第 1 層中看到。 \n ➢要查看圓錐體，請單擊查看→圖層設置 \n \n ➢您可以看到第 25 層有對象，而默認的工作層 1 沒有對象。 \n 錐體將再次出現在屏幕上。 保存文件，因為我們 \n 將在本教程的後面部分中使用它。 \n \n 2.5 協調系統 \n NX 中有不同的坐標系。 三軸符號用於標識坐標系。 \n 2.5.1 絕對坐標系 \n 絕對坐標係是從所有對像都被引用。 這是一個固定的坐標系， NX 12 建模空間中每個對象的位置和方向是與這個系統有關。 絕對坐標系（或絕對 CSYS ）還提供了通用的參考框架零件文件。 一個零件文件中 X = 1 ， Y = 1 和 Z = 1 的絕對位置是其他零件文件中的相同位置。 \n \n 圖形窗口左下角的 View Triad 僅是視覺對象代表絕對坐標系方向的指示器模型。 \n \n 2.5.2 工作坐標系 \n 工作坐標系（ WCS ）是您要用於構造時要使用的確定特徵的方向和角度。 \xa0 WCS 的軸表示為 XC ， YC 和 ZC 。（“ \xa0 C ”代表“當前”）。 它可能有多個坐標零件文件中的系統，但其中只有一個可以是工作坐標系。 \n 2.5.3 移動 WCS \n 在這裡，您將學習如何翻轉和旋轉 WCS 。 \n ➢選擇菜單→格式→ WCS \n \n 2.5.3.1 轉換 WCS \n 此過程將移動 WCS 原點到您指定的任何位置，但 WCS 的方向（軸的方向）將保持不變。 \n ➢選擇菜單→格式→ WCS →原點 \n \n 顯示“構造器”對話框。 你可以從頂部的下拉菜單中指定一個點對話框或在 XC ， YC ，和 ZC 字段。大部分工作將與工作有關坐標系而不是絕對坐標系統。 默認為 WCS 。 \n 2.5.3.2 旋轉 WCS \n 您還可以圍繞其軸線之一旋轉 WCS 。 \n ➢選擇菜單→格式→ WCS →旋轉 \n 該對話框顯示了六種旋轉 WCS 的方法。這些旋轉程序遵循正確的旋轉規則。 您還可以指定 WCS 被旋轉。 \n 您可以保存要使用的 WCS 的當前位置和方向作為永久坐標系。 \n ➢選擇菜單→格式→ WCS →保存 \n 2.6 工具欄 \n 工具欄包含圖標，可作為許多功能的快捷方式。右圖正常顯示了工具欄的主要項目顯示。但是，您可以找到更多不同圖標功能命令，基於所選模塊以及模塊是如何定制的。 \n \n 右鍵單擊現有工具欄上的任何位置，將提供其他工具欄的列表。 您可以通過選擇添加任何工具欄。 \n 通常，默認設置對於大多數操作應該足夠了，但是在某些操作期間，可能需要其他工具欄。 如果要添加與命令和工具欄有關的按鈕 \n ➢單擊任何工具欄上的下拉箭頭，然後選擇“自定義” \n \n 這將彈出“自定義”對話框窗口，其中包含“命令”選項卡下所有與每個工具欄有關的工具欄和命令。 要添加命令 \n ➢選擇一個類別並將命令從“命令”列表中拖動到所需的位置 \n \n 您可以通過以下方式自定義 NX 12 界面的設置單擊資源欄上的“角色”選項卡。角色選項卡具有工具欄菜單的不同設置顯示在 NX 12 界面上。 它可以讓你自定義您希望在工具欄中顯示的工具欄接口。 \n \n', 'tags': '', 'url': '第二章.html'}, {'title': '第七章', 'text': '第7章-自由曲面建模 \n \xa0\xa0\xa0 在本章中，您將學習如何在NX 12中創建自由曲面。至此，您已經擁有了學習了使用“表單特徵”或“草圖繪製”創建模型的不同方法。自由曲面建模涉及為美觀或功能目的以曲面形式創建模型， \n \n 7.1概述 \n \xa0\xa0\xa0 在NX 12中，“自由格式功能”選項位於 Menu → Insert → Surface/Mesh Surface/Sweep/Flange Surface 和 Menu → Edit → Surface 更高級操作。您可以通過多種方式從現有的方式創建自由格式功能您擁有的特徵（例如點，邊，曲線等）。 \n 7.1.1從點創建自由特徵 \n \xa0\xa0\xa0 如果您正在構造或預先存在的數據僅包含點，則您可以嘗試使用以下三個選項之一從給定點構建曲面\xa0\xa0\xa0 \n \xa0 \xa0 如果構造幾何包含兩個或多個字符串（曲線，面，邊線）以及彼此平行的一個或多個截面字符串垂直於第一組曲線（參考線），您可以嘗試使用以下選項之一建立自由曲面。 \n ➢從 Menu 點擊 Insert → Surface\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\xa0 \n Four Point Surface: \xa0 ：如果您有四個角點。 \n Through Points: 如果這些點形成一個矩形陣列。 \n From Poles: \xa0 如果定義的點形成一個矩形數組，該矩形數組與通過它們的線相切。 \n \n 7.1.2通過節字符串創建自由形式的特徵 \n \xa0\xa0\xa0 如果構造幾何包含連接的字符串對象（曲線和邊緣），可以使用以下之一創建自由曲面的兩個選項 \n \xa0\xa0\xa0 如果構造幾何包含兩個或多個字符串（曲線，面，邊線）以及彼此平行的一個或多個截面字符串垂直於第一組曲線（參考線），您可以嘗試使用以下選項之一建立自由曲面。 \n ➢從 Menu 點擊 Insert → Mesh Surface \n Ruled:   如果您有兩個大致平行的字符串。 \n Through Curves:   如果三個或三個以上的字符串大致相同平行。 \n 如果構造幾何包含兩個或多個字符串（曲線，面，邊線）以及彼此平行的一個或多個截面字符串垂直於第一組曲線（參考線），您可以嘗試使用以下選項之一建立自由曲面。 \n \n Through Curve Mesh: 如果至少四節使用弦在每個方向上都存在至少兩個弦（平行和垂直）。 \n Swept:   如果至少兩個截面弦大致垂直，則使用 \n ( 從 Menu 選擇 Insert →Sweep ) 7.1.3從面孔創建自由特徵 如果構造幾何包含圖紙或面，則可以使用以下兩個選項之一來構造自由曲面。 Offset Surface:  如果您要偏移面，請使用此選項。 ( 從  Menu  點擊  Insert →Offset/Scale ) \n Extension:   如果您有臉部和邊緣，邊緣曲線或臉部曲線，請使用此選項。（點擊 Insert →Flange Surface →Extension ) 7.2自由形式的功能建模 讓我們來進行一些自由結構建模的練習，其中包括結構化點，點雲，曲線和面孔。 結構化點是一組點的已定義行和列。點雲具有一組形成雲的分散點。 7.2.1用點建模 ➢打開文件 freeform_thrupoints.prt ➢右鍵單擊 Toolbars 並確保 Surface Toolbar 被檢查 您將看到七行點 ➢選擇 Insert →Surface →Through Points \n or ➢單擊圖標 Through Points \n ( 在工具欄中對話框如右圖所示彈出 ) ➢對於 Patch Type 選擇 Multiple ➢對於 Closed Along 選擇 Neither ➢對於 Row Degree  and  Column Degree, ➢請點擊 OK 下一個對話框將如下圖所示。 ➢點擊 Chain from All ➢選擇頂部起點和底部終點最左行的點，如下圖所示 點的第一行將突出顯示 。 ➢重複相同的過程以選擇點的前四行。之後，將彈出一個窗口，詢問是否所有點指定，或者如果您想指定另一行。 ➢選擇 Specify Another Row 直到所有行都指定的 ➢指定所有行後，選擇 All Points Specified ➢點擊 Cancel 在 Through Points 窗口 您將看到如下所示的表面。 7.2.2 用點雲建模. ➢打開名為 freeform_cloud.prt 點雲將如下所示。 ➢選擇 Insert → Surface → Fit Surface ➢單擊 Surface Toolbar 工具欄上的此圖標 Fit Surface 將出現以下對話框。 ➢單擊點雲，選擇屏幕上的所有點。 ➢在 Fit Direction 下拉菜單中，選擇 Best Fit 。這匹配點雲坐標系統與原始系統 ➢將 U 和 V 度的默認值更改為 3 ➢點擊 OK 最終表面將如下所示。 7.2.3 使用曲線建模. ➢打開名為 freeform_thrucurves_parameter.prt 的文件 曲線如下圖所示。 ➢選擇 Insert → Mesh Surface → Through Curves ➢選擇第一個 section string ，如下所示。確保選擇左側的某個位置弧線。 方向矢量顯示在字符串的末尾。 ➢單擊鼠標中鍵 MB2 或點擊 Add New Set ➢單擊與第一個相似的下一條曲線，然後單擊鼠標中鍵 MB2 你可以看到一個表面如圖所示，在兩條曲線之間生成 ➢重複相同的步驟以選擇其餘的字符串。 記得點擊 MB2 (or Add New Set)   選擇每條曲線後。 ➢對於 Alignment 選擇 Parameter ➢對於   Patch Type 選擇  Single \xa0  ➢對於   Construction 選擇 Simple 選擇“簡單”選項後，系統會嘗試構建最簡單的表面，使貼劑的數量最少。 ➢點擊 OK 7.2.4使用曲線和麵建模 ➢打開名為 freeform_thrucurves_faces.prt 的文件 曲線和面將顯示為對 ➢選擇   Insert →Mesh Surface →Through Curves ➢選擇頂面的 邊1。 ➢選擇 edge-2， 然後單擊 MB2 ➢在對話框中的 Alignment 部分，取消選中 Preserve Shape 校驗框 \n 您將在屏幕上顯示以下形狀。 \n 確保所有箭頭都指向同一方向（如果不是，請雙擊任一箭頭即可翻轉其方向）。 ➢在 Alignment 對話框選擇 Parameter ➢在 Continuity 對話框 for First Section 選擇 G2 (Curvature)  選項，然後選擇頂面的兩個斑塊 ➢點擊 APPLY ➢現在選擇edge-3，然後單擊 MB2 ➢選擇下平面的三個邊緣 ➢將選項更改為 G2 (Curvature)  在裡面 Continuity 對話框 First Section ➢選擇剛創建的表面，然後單擊 MB2 ➢對於 Continuity 的 Last Section,  選擇 G2 (Curvature)  然後選擇底部三個補丁作為參考 最終的自由曲面應如下所示。 ➢點擊 OK 退出 7.3練習 7.3.1曲線練習 上圖顯示了使用點作為“控制點”或“直通點”創建的三個曲線。下表列出了每條曲線的對應點和建模類型 \xa0 \n （a）在Curve-1和Curve-2之間創建直紋曲面。 \n （b）沿+ Y方向拉伸Curve-3以創建參考曲面。然後創建在Curve-2和Curve-3之間的曲面，該曲面應具有G1（切線）連續性到剛擠出的參考曲面。 \n 提示：您可以將這些點從文本文件導入NX。首先，將點坐標保存到文本文件。 \n 然後，使用“ NX文件”->“導入”->“文件中的點”將其導入。 \n 7.3.2表面練習 \n \n 給定2個點集，這些點集存儲在“ Fit curve.pts”和“ Fit surface.pts”文件中 \n （可在文件夾）。 \n （ a ）將這兩組點導入 NX 。 （上圖顯示了預期的結果） （b）根據“ Fit curve.pts”文件中的點創建樣條曲線。您可以使用 Fit Curve 要創建它，請調整 Degree  和  Segments 以獲得更好的擬合。 （c）根據“ Fit surface.pts”文件中的點創建自由曲面。您可以使用Fit Surface要創建它，請調整Degree 和 Patche以獲得更好的擬合度。 \n （d）使用樣條曲線作為邊界沿Z方向修剪自由曲面。的預期結果就像計算機鼠標的上表面。 7.3.3設計計算機鼠標 對與以下所示類似的計算機鼠標進行建模（可隨意搜索更多圖片，如下所示）參考資料），或者您可以提出一個新設計，然後對其建模。 作為提示，創建一些在不同基準平面上的邊界曲線，並使用它們創建自由曲面。 7.3.4設計運動水壺 \n 設計運動水壺，並使用 NX （曲線和曲面）中的自由形狀功能對其建模。 \n \n', 'tags': '', 'url': '第七章.html'}, {'title': '第八章', 'text': '第 8 章－有限元分析 \n 有限元分析（ FEA ）是有限元方法（ FEM ）的實際應用預測結構或流體對應用因素（例如力，壓力，熱量和振動。通常，該過程從創建幾何模型開始。然後將模型細分（網格化）為連接的簡單幾何形狀的小塊（元素）在特定的節點上。材料特性和邊界條件分別應用於元件。最終，諸如 NX 12 之類的軟件解決了該 FEA 問題並輸出了結果，可視化。它有助於工程師在使用之前更好地了解產品性能。它是經過製造和測試的。 \n FEA的一些應用包括結構分析，熱分析，流體流動動力學，和電磁兼容性。其中， FEA 最常用於結構和實體力學應用程序來計算機械性能（例如應力和位移）。這些通常對硬件的性能至關重要，可用於預測故障。在在本章中，我們將處理實體零件的結構應力和應變分析。 \n 8.1概述 \n 8.1.1元素形狀和節點 \n 可以根據維數和元素的類型將元素分為不同類型。元素中的節點數。以下是一些用於離散化 \n 一維元素 \n \n 二維元素 \n 三角形： \n \n 四邊形： \n \n 三維元素 \n 四面體（具有4個三角形面的實體）： \n \n 六面體（具有 6 個四邊形面的實體）： \n \n 節點類型 \n 外部節點 \n 1角節點 \n 2側節點 \n 內部節點 \n 通常，隨著有限元的大小變小， FEA 可以有更精確的解決方案，但是計算時間也會變長。 \n 8.1.2解決步驟 \n 開始仿真： 您可以從以下之一選擇求解器： NX Nastran ， NX Nastran 聲學， NX Nastran 振動聲學， NX Nastran 設計， Samcef ， NX 熱 / 流量， Simcenter 電子系統冷卻， Simcenter 空間系統熱學， NX Multiphysics ， Simcenter Acoustics BEM ， MSC Nastran ， Ansys ， Abaqus 和 LS-DYNA 。另外，您可以選擇要執行的分析類型。在本教程中，僅結構分析將是覆蓋了 NX Nastran 設計。 \n 選擇材料屬性： 這使您可以更改將要分配給模型。例如，如果我們使用鋼製造葉輪，則可以輸入材料特性，例如密度，泊鬆比等。也可以保存這些材料特性可以在圖書館中使用以備將來使用，也可以從材料庫中檢索。 \n 施加載荷： 此選項使您可以施加不同類型的載荷，例如力或固體上的壓力以及方向和大小。 \n 應用邊界條件： 簡單來說，邊界條件限制了度元素的自由。一些元件可以旋轉固定，而某些則可以限制來自平移運動。 \n 網格物體網格劃分： 用於將模型離散化為有限元。通常，我們選擇 \n 元素的四面體形狀近似。您仍然可以選擇 2D 和 1D 元素 \n 根據情況和要求，從下拉菜單中選擇這些選項。 \n 解決方案和結果： 這是根據選定的問題求解所有控制方程的命令 \n 解算器以及以上所有選項。這樣就可以解決問題並給出分析結果。 \n \n \n \n \n \n \n 8.1.3仿真導航器 \n Simulation Navigator提供了激活功能現有解決方案，創建新解決方案，並使用創建的解決方案通過創建和修改運動對象來構建機制。 \n 要顯示 Simulation Navigator ， \n ➢點擊 Simulation Navigator 標籤中 Resource bar 如圖所示 \n \n 它顯示了為模型創建的仿真的列表。每一個模擬，它顯示載荷，邊界條件，類型的列表網格，結果，生成的報告等。 \n 8.2模擬創建 \n ➢複製並粘貼文件 Impeller_impeller.prt 進入新文件夾以避免更改組裝而成 \n ➢點擊 New → Simulations 如果零件尚未在 NX 窗口中打開 \n \n ➢打開這個新復制的文件\xa0 \n ➢如果零件已經在 NX 中打開，則從頂部功能區欄中，單擊 Application → Design \n \n ➢點擊 File → All Applications → Simulation → Design Simulation \n \n 首次在 Design Simulation 模塊中打開任何文件時，它將自動彈出“新建” FEM 和模擬對話框可創建模擬。 \n ➢在彈出對話框中，單擊“確定”以創建新的仿真。 \n 然後在下一個彈出的“解決方案”窗口中，可以選擇“求解器”和“分析類型”。默認的求解器類型為 NX Nastran 設計，分析類型為結構。 \n ➢選擇 OK 創建一個新的 Solution 稱為解決方案 1 ，它將顯示在 Simulation Navigator 。在這裡，我們將其他項保留為默認值。 \n \n 現在，模擬導航器將如下圖所示。 \n \n 8.3材料性能 \n 下一步是將材料屬性分配給此模擬的實體模型。因為庫中沒有任何數據可檢索標準材料，我們將創建一個。讓我們假設我們將使用鋼製造葉輪。 \n \n ➢點擊 Assign Materials 從上方顯示的功能區欄中 \n 彈出分配材料窗口。您可以選擇從庫中選擇預定義的材料，或者創建一種新材料。 \n ➢選擇 Impeller 對於 Select Body \n ➢點擊 Create 圖標以創建新材料 \n 輸入名稱和值，如下圖所示。注意單位。 \n （請注意， 30e6 代表 30×10^6 ） \n ➢選擇 OK 退出 Isotropic Material 窗口 \n \n 現在，我們已將材料分配給葉輪模型。 \n \n 8.4網格化 \n 網格選項將模型離散化為小模型元素。 \n ➢點擊 3D Tetrahedral 圖標 ctetra \n 將會彈出一個窗口，詢問類型和元素的大小。 \n ➢首先，單擊 impeller model 在屏幕上 Select Bodies \n 然後，有兩種類型的四面體NX 12中可用的元素。一個是4節點，另一個是10節點。 \n ➢選擇 Type 成為 TETRA(10) \n ➢輸入 Element Size 如 \xa0 1.0 inch \n ➢點擊 OK \n \n 您可以找到帶有小四面體的模型元素。看起來如圖所示下面。 \n \n 注意：在對實體進行網格劃分時，需要權衡考慮。如果您選擇較小的具有更大節點的元素，您將比大元素獲得更高的分析精度。 \n 但是，使用較小的元素求解模型所需的時間將比使用較小的元素所需的時間長得多。較大的元素。因此，根據研究的準確性要求以及根據最終產品來選擇組件，為元素選擇適當的參數，然後節點。 \n \n 8.5負載 \n 實體模型上施加的載荷應輸入到系統中。對於葉輪，假設主力作用在渦輪葉片的凹表面上。該負載可以近似在所有五個表面上施加常壓。由於我們不關心負載，讓我們將值設為 100 lbf/in^2 英寸以誇大葉片的變形。 \n ➢點擊 Load Type 然後選擇 Pressure \n ➢單擊五個凹面刀片如下圖所示 \n ➢輸入以下值 Pressure 為 100 和保持單位為 lbf / in ^ 2 （磅 / 平方英寸） \n \n \n 8.6邊界條件 \n 如您在組裝中看到的，葉輪與軸一起圍繞圓錐體的軸線旋轉。前幾章。它不是固定的，但我們關注的是葉片相對於葉輪的核心。圓錐形芯子相對固定，葉片變形是進行相應的分析。 \n ➢點擊 Constraint Type \n ➢選擇 Fixed Constraint \n \n 這種約束將將所選實體限制為六個自由度來自平移和旋轉。您可以通過點擊工具欄上的“約束類型”下拉菜單。 \n ➢單擊葉輪的錐形表面，如下圖所示 \n ➢點擊OK \n \n 8.7結果與模擬 \n 8.7.1解決模擬 \n 有限元模型現在可以進行求解和分析了。最好先檢查一下在完成模型求解之前先完成模型。檢查模型 \n ➢點擊 Menu → Analysis → Finite Element Mode Check → Model Setup 點擊 \n Model \xa0 Setup 中的圖標 Checks and Information 在功能區欄中分組如右圖所示， \n 這將彈出一個窗口。 \n ➢選擇 OK \n \n 這將顯示檢查操作的結果。您將在單獨的地方看到任何錯誤和警告窗口。萬一您收到錯誤或警告，請返回完成前面的步驟並完成所需的操作東西。如果您沒有收到錯誤或警告，那麼您就是準備解決 FEA 問題。 \n \n ➢點擊 Solve \n 這將打開“求解”窗口。 \n ➢單擊 OK 而不進行任何更改 \n \n 解決這項工作可能需要一段時間。等到出現“分析作業監視器”窗口，顯示要完成的工作。當求解器正在執行時計算， Analysis Job Monitor 將顯示為進行中 \n ➢點擊 Cancel 當 Analysis Job Monitor 的時候窗口顯示 Completed \n \n 8.7.2 FEA結果 \n ➢從 Simulation Navigator 雙擊 Structural 下 Results \n ➢您將被定向到 Post Processing Navigator \n 後處理導航器顯示您剛剛解決的所有解決方案。如果您點擊“ +”登錄在解決方案的前面，您將看到對模型執行的不同分析。 \n \n ➢雙擊 Displacement-Nodal \n 屏幕現在如下所示。您可以輕鬆地解釋顏色編碼的結果。橘紅色顯示最大變形區域，藍色區域顯示最大變形區域。最小變形區。您可以觀察到，由於圓錐形核心是固定的，因此會遇到零變形。分析還表明，尖端出現的最大變形刀片的數量約為1.9×10^-3英寸。 \n \n 在後處理導航器上，您可以通過雙擊每個來繼續更改結果選項如下所示。您可以單擊其他無效標記以查看各種結果。一些其他結果如下所示。 \n \n 8.7.3仿真和動畫 \n \n ➢點擊 Animate \n ➢在 Animation 窗口，更改數量幀數為 10 ，然後單擊 Play 按鈕查看變形動畫 \n 現在，您可以看到有關葉輪運行方式的動畫在將載荷施加到葉片時變形。 \n ➢要在結果顯示中進行任何設置更改，點擊 Edit Post View \n ➢檢查 Show undeformed mode l 然後點擊 OK \n \n 現在，按“播放”按鈕以查看動畫。這將顯示變形的動畫原始形狀為灰色，如下圖所示 \n \n ➢點擊 Stop 按鈕停止動畫 \n ➢點擊 \xa0 Return to Home 返回到 FEA 模型 \n 有兩種方法可以提高 FEA 結果的準確性： \n •減少元素的大小 \n •增加插值多項式的階數（即，使用二次甚至偶數代替線性多項式） \n 讓我們嘗試使用不同的設置創建模擬 \n ➢右鍵單擊 Solution 1 在裡面 Simulation Navigator \n ➢選擇 Clone 複製第一個模擬 \n ➢一次 Copy of Solution 1 被建造，重命名為 Solution 2 \n ➢從 Simulation Navigator, under 3D Meshes 右鍵單擊 3D Mesh \n （ 1 ）然後單擊 Edit \n ➢在彈出對話框中，更改 Type 至 TETRA4 \n ➢點擊 OK \n ➢點擊 Solve 圖標來解決模擬 \n ➢點擊 OK \n \n 分析作業監視器應顯示狀態解決方案 2 的完成。 \n ➢點擊 Cancel \n ➢在 Simulation Navigato r 連按兩下上 Results for Solution 2 \n 下圖顯示了分析。您可以觀察最大值的變化。保存所有模擬並關閉文件。 \n \n 8.8練習 \n 8.8.1喬木壓桿 \n 開啟檔案 ‘Arborpress_L-bar.prt’ \xa0 ”，並根據材料進行類似的結構分析作為鋼。對於網格，元素的大小和類型應為“ \xa0 10 ”和“ \xa0 Tetra （ 10 ）”。對於負載如上圖所示，在頂面上施加 500 級的法向壓力下面。 \n 對於邊界條件，固定三個平面（前高亮面，與如下圖第二個圖所示。 \n \n 8.8.2搖臂 \n 在本練習中，您將檢查單元類型和網格大小對有限結果的影響元素分析。打開您在第4章中建模的搖臂。分配以下材料性質：楊氏模量= 3.0×10 ^ 7psi，泊鬆比= 0.29，質量密度= 7.35×10 ^ -4金屬塊/ in3。固定沉孔和沈孔（即固定圓柱面）如下圖所示，並在面部垂直施加600 psi的壓力負載顯示。對於以下四種情況，分別獲得撓度輪廓和馮·米塞斯應力輪廓。 \n \n a) \xa0 Tetra 4 元素，元素大小 -0.2 \n b) \xa0 Tetra 4 元素，元素大小 - 05 \n c) \xa0 Tetra 10 元素，元素大小 -0.2 \n d) \xa0 Tetra 10 元素，元素大小 - 05 \n \n \n CHAPTER 8 \n', 'tags': '', 'url': '第八章.html'}, {'title': 'NX12', 'text': '', 'tags': '', 'url': 'NX12.html'}, {'title': 'NX12零組件繪圖', 'text': '\n', 'tags': '', 'url': 'NX12零組件繪圖.html'}, {'title': 'W17協同任務', 'text': '', 'tags': '', 'url': 'W17協同任務.html'}, {'title': 'Building a clean model tutorial', 'text': '', 'tags': '', 'url': 'Building a clean model tutorial.html'}, {'title': '40723111', 'text': "\xa0Author:40723111 \n 建構乾淨的模型教程 Building a clean model tutorial \n This tutorial will guide you step-by-step into building a clean simulation model, of a robot, or any other item. This is a very important topic, maybe the most important aspect, in order to have a nice looking, fast displaying, fast simulating and stable simulation model. \n 本教程將指導您逐步建構機器人或任何其他項目的清晰仿真模型。為了具有美觀，快速顯示，快速仿真和穩定的仿真模型，這是一個非常重要的主題，也許是最重要的方面。 \n To illustrate the model building process, we will be building following manipulator: \n 為了說明模型的建構過程，我將建構以下的機械手臂 : \n \n [機械手模型] \n 建立可見的形狀Building the visible shapes \n When building a new model, first, we handle only the visual aspect of it: the dynamic aspect (its undelying even more simplified/optimized model), joints, sensors, etc. will be handled at a later stage. \n 在構建新模型時，首先，我們僅處理它的視覺方面：動態方面（其簡化，優化模型的不合理之處），關節，傳感器等將在以後階段進行處理。 \n We could now directly create primitive shapes in CoppeliaSim with [Menu bar --> Add --> Primitive shape --> ...]. When doing this, we have the option to create pure shapes, or regular shapes. Pure shape will be optimized for dynamic interaction, and also directly be dynamically enabled (i.e. fall, collide, but this can be disabled at a later stage). Primitive shapes will be simple meshes, which might not contain enough details or geometric accuracy for our application. Our other option in that case would be to import a mesh from an external application. \n 現在，我們可以使用 [ 菜單欄 -> 添加 -> 基本形狀 -> ...] 在 CoppeliaSim 中直接創建基本形狀。這樣做時，我們可以選擇創建純形狀或常規形狀。純形狀將針對動態交互進行優化，也可以直接動態啟用（例如，跌落，碰撞，但可以在以後禁用）。基本形狀將是簡單的網格，對於我們的應用程序，可能沒有足夠的細節或幾何精度。在這種情況下，我們的另一個選擇是從外部應用程序導入網格。 \n When importing CAD data from an external application, the most important is to make sure that the CAD model is not too heavy, i.e. doesn't contain too many triangles. This requirement is important since a heavy model will be slow in display, and also slow down various calculation modules that might be used at a later stage (e.g.\xa0minimum distance calculation, or dynamics). Following example is typically a no-go (even if, as we will see later, there are means to simplify the data within CoppeliaSim): \n 從外部應用程序導入 CAD 數據時，最重要的是確保 CAD 模型不會太複雜，即不包含太多三角形。這項要求很重要，因為重型模型的顯示速度會很慢，並且還會減慢以後可能使用的各種計算模塊（例如最小距離計算或動力學）。以下示例通常是不可行的（即使我們會在後面看到，即使有方法可以簡化 CoppeliaSim 中的數據）： \n \n [ 複雜的 CAD 數據（實體和線框）] \n Above CAD data is very heavy: it contains many triangles (more than 47'000), which would be ok if we would just use a single instance of it in an empty scene. But most of the time you will want to simulate several instances of a same robot, attach various types of grippers, and maybe have those robots interact with other robots, devices, or the environment. In that case, a simulation scene can quickly become too slow. Generally, we recommend to model a robot with no more than a total of 20'000 triangles, but most of the time 5'000-10'000 triangles would just do fine as well. Remember: less is better, in almost every aspect. \n 上面的 CAD 數據非常大：它包含許多三角形（超過 47'000 個），如果我們只在空的場景中使用單個三角形的實例，這是可以的。但是大多數時候，您將需要模擬同一機器人的多個實例，連接各種類型的夾爪，並可能使這些機器人與其他機器人，設備或環境進行交互。在這種情況下，模擬場景可能很快變得太慢。通常，我們建議對不超過 2 萬個三角形的機器人進行建模，但是在大多數情況下， 5 000 至 10 000 個三角形也可以。記住：在幾乎所有方面，少即是好。 \n What makes above model so heavy? First, models that contain holes and small details will require much more triangular faces for a correct representation. So, if possible, try to remove all the holes, screws, the inside of objects, etc. from your original model data. If you have the original model data represented as parametric surfaces/objects, then it is most of the time a simple matter of selecting the items and deleting them (e.g. in Solidworks). The second important step is to export the original data with a limited precision: most CAD applications let you specify the level of details of exported meshes. It might also be important to export the objects in several steps, when the drawing consists of large and small objects; this is to avoid having large objects too precisely defined (too many triangles) and small objects too roughly defined (too few triangles): simply export large objects first (by adjusting the desired precision settings), then small objects (by adjusting up precision settings). \n 是什麼使上述模型如此大？首先，包含孔和小細節的模型將需要更多的三角形面才能正確表示。因此，如果可以，請嘗試從原始模型數據中刪除所有的孔，螺釘，物體的內部等。如果您將原始模型數據表示為參數化曲面 / 對象，則通常在大多數情況下只需選擇並刪除它們即可（例如在 Solidworks 中）。第二個重要步驟是以有限的精度導出原始數據：大多數 CAD 應用程序都允許您指定導出的網格的細節級別。當工程圖由大小對象組成時，分幾步導出對象可能也很重要。這是為了避免大對象定義太精確（三角形太多）和小對象定義太粗（三角形太少）：首先簡單地導出大對象（通過調整所需的精度設置），然後導出小對象（通過調整精度設置） ）。 \n CoppeliaSim supports currently following CAD data formats: OBJ, STL, DXF, 3DS (Windows only), and Collada. URDF is also supported, but not mentionned here since it is not a pure mesh-based file format. \n CoppeliaSim當前支持以下 CAD 數據格式： OBJ ， STL ， DXF ， 3DS （僅 Windows ）和 Collada 。還支持 URDF ，但此處未提及，因為它不是基於純網格的文件格式。 \n Now suppose that we have applied all possible simplifications as described in previous section. We might still end-up with a too heavy mesh after import: \n 現在，假設我們已按照上一節中所述應用了所有可能的簡化。導入後，我們可能最終仍然會留下一個過大的網格： \n \xa0 \n [導入的CAD數據] \n You can notice that the whole robot was imported as a single mesh. We will see later how to divide it appropriately. Notice also the wrong orientation of the imported mesh: best is to keep the orientation as it is, until the whole model was built, since, if at a later stage we want to import other items that are related to that same robot, they will automatically have the correct position/orientation relative to the original mesh. \n 您會注意到整個機器人是作為單個網格導入的。稍後我們將看到如何對其進行適當劃分。還要注意導入網格的方向錯誤：最好保持其方向不變，直到構建整個模型為止，因為如果在以後的階段中我們要導入與同一機器人相關的其他項目，它們將自動具有相對於原始網格的正確位置 / 方向。 \n At this stage, we have several functions at our disposal, to simplify the mesh: \n 在此階段，我們可以使用多種功能來簡化網格： \n ˙ Automatic mesh division: \xa0allows to generate a new shape for all elements that are not linked together via a common edge. This does not always work for the selected mesh, but is always worth a try, since working on mesh elements gives us more control than if we had to work on all elements at the same time. The function can be accessed with [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes]. Sometimes, a mesh will be divided more than expected. In that case, simply merge elements that logically belong together (i.e. that will have the same visual attributes and that are part of the same link) back into one single shape ([Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes]). \n ˙ 自動網格劃分 ：允許為未通過公共邊鏈接在一起的所有元素生成新形狀。這並不總是適用於選定的網格，但是總是值得一試的，因為與必須同時處理所有元素相比，處理網格元素可以為我們提供更多的控制權。可以通過 [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 分割所選形狀 ] 訪問該功能。有時，網格劃分會超出預期。在這種情況下，只需將邏輯上屬於一起的元素（即，具有相同的視覺屬性並且屬於同一鏈接的一部分）合併回一個單一形狀（ [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 合併選定的形狀 ] ）。 \n ˙ Extract the convex hull : \xa0allows to simplify the mesh by transforming it into a convex hull. The function can be accessed with [Menu bar --> Edit --> Morph selection into convex shapes]. \n ˙ 提取凸殼 ：通過將其轉換為凸殼來簡化網格。可以通過 [ 菜單欄 -> 編輯 -> 將選擇變形為凸形 ] 來查看該功能。 \n ˙ Decimate the mesh : \xa0allows to reduce the number of triangles contained in the mesh. The function can be accessed with [Menu bar --> Edit --> Decimate selected shape...]. \n ˙抽取網格 ：減少網格中包含的三角形數量。可以通過 [ 菜單欄 -> 編輯 -> 縮小所選形狀 ...] 查看該功能。 \n ˙ Remove the inside of the mesh : \xa0allows to simplify the mesh by removing its inside. This function is based on\xa0 vision sensors \xa0and might give more or less satisfying results depending on the selected settings. The function can be accessed with [Menu bar --> Edit --> Extract inside of selected shape]. \n ˙ 刪除網格的內部 ：允許通過刪除其內部來簡化網格。此功能基於視覺傳感器，根據所選設置可能會或多或少地令人滿意。可以通過 [ 菜單欄 -> 編輯 -> 提取選定形狀的內部 ] 查看該功能。 \n There is no predefined order in which above functions can/should be applied (except for the first item in the list, which should always be tried first), it heavily depends on the geometry of the mesh we are trying to simplify. Following image illustrates above functions applied to the imported mesh (let's suppose the first item in the list didn't work for us): \n 沒有可以應用上述功能的預定義順序（列表中的第一項除外，應始終首先嘗試該項），它在很大程度上取決於我們要簡化的網格的幾何形狀。下圖說明了應用於導入的網格的上述功能（假設列表中的第一項對我們不起作用）： \n \n [凸殼，抽取網格並在內部提取 ] \n Notice how the convex hull doesn't help us at this stage. We decide to use the mesh decimation function first, and run the function twice in order to divide the number of triangles by a total of 50. Once that is done, we extract the inside of the simplified shape and discard it. We end-up with a mesh containing a total of 2'660 triangles (the original imported mesh contained more than 136'000 triangles!). The number of triangles/vertices a shape contains can be seen in the shape geometry dialog. 2'660 triangles are extremely few triangles for a whole robot model, and the visual appearance might suffer a little bit from it. \n 請注意，凸殼在現階段對我們沒有幫助。我們決定首先使用網格抽取功能，然後運行兩次該功能，以將三角形的數量總共除以 50 。完成後，我們提取簡化形狀的內部並將其丟棄。我們最終得到的網格總共包含 2'660 個三角形（原始導入的網格包含了 136'000 個三角形！）。形狀包含的三角形 / 頂點的數量可以在形狀幾何對話框中看到。對於整個機器人模型， 2'660 三角形是極少的三角形，因此視覺外觀可能會因此受到影響。 \n At this stage we can start to divide the robot into separate links (remember, we currently have only a single shape for the whole robot). You can do this in two different ways: \n 在這一階段，我們可以開始將機器人劃分為單獨的鏈接（請記住，我們目前整個機器人只有一個形狀）。您可以通過兩種不同的方式執行此操作： \n ˙ Automatic mesh division: \xa0this function, which was already described in previous section, will inspect the shape and generate a new shape for all elements that are not linked together via a common edge. This does not always work, but is always worth a try. The function can be accessed with [Menu bar --> Edit --> Grouping/merging --> Divide selected shapes]. \n ˙ 自動網格劃分 ：此功能已在上一節中進行了描述，它將檢查形狀並為未通過公共邊鏈接在一起的所有元素生成新形狀。這並不總是有效，但總是值得嘗試的。可以通過 [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 分割所選形狀 ] 查看該功能。 \n ˙ Manual mesh division: \xa0 via the the triangle edit mode, you can manually select the triangles than logically belong together, then click Extract shape. This will generate a new shape in the scene. Delete the selected triangles after that operation. \n ˙ 手動網格劃分 ：通過三角形編輯模式，您可以手動選擇邏輯上不屬於邏輯的三角形，然後單擊“提取形狀”。這將在場景中生成新形狀。完成該操作後，刪除選定的三角形。 \n In the case of our mesh, method 1 worked fine: \n 對於我們的網格，方法 1 可以正常工作： \n \n [網格劃分 ] \n Now, we could further refine/simplify individual shapes. Sometimes also, a shape might look better if its convex hull is used instead. Othertimes, you will have to use several of above's described techniques iteratively, in order to obtain the desired result. Take for instance following mesh: \n 現在，我們可以進一步細化 / 簡化單個形狀。有時，如果改用凸包，形狀可能會看起來更好。有時，您將不得不反複使用上述幾種技術，以獲得所需的結果。以以下網格為例： \n \n [外部網格 ] \n", 'tags': '', 'url': '40723111.html'}, {'title': '40723121', 'text': "by40723121 \n The problem with above's shape is that we cannot simplify it nicely, because of the holes it contains. So we have to go the more complicated way via the\xa0 shape edit mode , where we can extract individual elements that logically belong to the same convex sub-entity. This process can take several iterations: we first extract 3 approximate convex elements. For now, we ignore the triangles that are part of the two holes. While editing a shape in the shape edit mode, it can be convenient to switch the\xa0 visibility layers , in order to see what is covered by other scene items. \n 上面形狀的問題是，由於其中包含孔，我們無法很好地簡化它。因此，我們必須通過形狀編輯模式進行更複雜的處理，在該模式下，我們可以提取邏輯上屬於同一凸形子實體的單個元素。此過程可能需要進行多次迭代：我們首先提取 3 個近似凸元素。現在，我們忽略作為兩個孔的一部分的三角形。在形狀編輯模式下編輯形狀時，可以方便地切換可見性圖層，以查看其他場景項所覆蓋的內容。 \n \xa0 \n \n \xa0 \n We end up with a toal of three shapes, but two of them will need further improvement. Now we can erase the triangles that are part of the holes. Finally, we extract the convex hull individually for the 3 shapes, then merge them back together with [Menu bar --> Edit --> Grouping/Merging --> merge selected shapes]: \n 我們最終得到三個形狀的總和，但是其中兩個將需要進一步改進。現在我們可以擦除作為孔的一部分的三角形。最後，我們分別提取 3 種形狀的凸包，然後將其與 [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 合併所選形狀 ] 合併在一起： \n \xa0 \n \xa0 \n \xa0 \n In CoppeliaSim, we can enable/disable edge display for each shape. We can also specify an angle that will be taken into account for the edge display. A similar parameter is the\xa0 shading angle , that dictates how facetted the shape will display. Those parameters, and a few others such as the shape\xa0 color , can be adjusted in the\xa0 shape properties . Remember that\xa0 shapes come in various flavours . In this tutorial we have only dealt with simple shapes up to now: a simple shape has a single set of visual attributes (i.e. one color, one shading angle, etc.). If you merge two shapes, then the result will be a simple shape. You can also group shapes, in which case, each shape will retain its visual attributes. \n 在 CoppeliaSim 中，我們可以啟用 / 禁用每種形狀的邊緣顯示。我們還可以指定邊緣顯示時要考慮的角度。相似的參數是陰影角，它指示形狀將在多方面顯示。這些參數以及其他一些參數（例如形狀顏色）可以在形狀屬性中進行調整。請記住，形狀有多種風味。到目前為止，在本教程中，我們僅處理簡單的形狀：簡單的形狀具有一組視覺屬性（即一種顏色，一個陰影角度等）。如果合併兩個形狀，則結果將是一個簡單的形狀。您還可以對形狀進行分組，在這種情況下，每個形狀將保留其視覺屬性。 \n \xa0 \n In next step, we can merge elements that logically belong together (if they are part of the same rigid element, and if they have the same visual attributes). Then we change the visual attributes of the various elements. The easiest ist to adjust a few shapes that have different colors and visual attributes, and if we name the color with a specific string, we can later easily programmatically change that color, also if the shape is part of a compound shape. Then, we select all the shapes that have the same visual attributes, then control-select the shape that was already adjusted, then click\xa0 Apply to selection , once for the\xa0 Colors , once for the\xa0 other properties , in the\xa0 shape properties : this transfers all visual attributes to the selected shapes (including the color name if you provided one). We end up with 17 individual shapes: \n \xa0 \n \xa0 \n 在下一步中，我們可以合併邏輯上屬於一起的元素（如果它們屬於同一剛性元素，並且具有相同的視覺屬性）。然後，我們更改各種元素的視覺屬性。調整具有不同顏色和視覺屬性的幾種形狀的最簡便方法，如果我們使用特定的字符串來命名顏色，則以後可以輕鬆地以編程方式更改該顏色，即使該形狀是複合形狀的一部分。然後，我們選擇所有具有相同視覺屬性的形狀，然後控制選擇已調整的形狀，然後單擊“應用於選擇”，一次是“顏色”，一次是其他屬性，在形狀屬性中：這將轉移所有所選形狀的視覺屬性（如果提供的話，還包括顏色名稱）。我們最終得到 17 個單獨的形狀： \n \n Now we can group the shapes that are part of the same link with [Menu bar --> Edit --> Grouping/merging -> Group selected shapes]. We end up with 7 shapes: the base of the robot (or base of the robot's hierarchy tree), and 6 mobile links. It is also important to correctly name your objects: you we do this with a double-click on the object name in the\xa0 scene hierarchy . The base should always be the robot or model name, and the other objects should always contain the base object name, like:\xa0 robot \xa0(base),\xa0 robot_link1 ,\xa0 robot_proximitySensor , etc. By defaut, shapes will be assigned to visibility layer 1, but can be changed in the\xa0 object common properties . By default, only\xa0 visibility layers 1-8 are activated for the scene . We now have following (the model\xa0 ResizableFloor_5_25 \xa0was temporarily made invisible in the\xa0 model properties dialog ): \n \xa0 \n 現在，我們可以使用 [ 菜單欄 -> 編輯 -> 分組 / 合併 -> 分組所選形狀 ] 對屬於同一鏈接的形狀進行分組。我們最終得到 7 個形狀：機器人的基礎（或機器人的層次結構樹的基礎）和 6 個移動鏈接。正確命名對像也很重要：您可以通過雙擊場景層次結構中的對象名稱來做到這一點。基礎應始終是機械手或模型名稱，其他對象應始終包含基礎對象名稱，例如： robot （基礎）， robot_link1 ， robot_proximitySensor 等。通過默認，形狀將分配給可見性層 1 ，但可以在對象通用屬性中進行更改。默認情況下，僅激活場景的可見性層 1-8 。現在，我們有了以下內容（模型 ResizableFloor_5_25 模型在模型屬性對話框中暫時不可見）： \n \xa0 \n When a shape is created or modified, CoppeliaSim will automatically set its reference frame position and orientation. A shape's reference frame will always be positioned at the shape's geometric center. The frame orientation will be selected so that the shape's bounding box remains as small as possible. This does not always look nice, but we can always reorient a shape's reference frame at any time. We now reorient the reference frames of all our created shapes with [Menu bar --> Edit --> Reorient bounding box --> with reference frame of world]. You have more options to reorient a reference frame in the\xa0 shape geometry dialog . \n 創建或修改形狀時， CoppeliaSim 將自動設置其參考框架的位置和方向。形狀的參考框架將始終位於形狀的幾何中心。將選擇框架方向，以便形狀的邊界框保持盡可能小。這並不總是看起來不錯，但是我們隨時可以隨時調整形狀的參考框架的方向。現在，我們可以使用 [ 菜單欄 -> 編輯 -> 重定向邊界框 -> 使用世界參考框架 ] 重新調整所有已創建形狀的參考框架。您有更多選項可以在形狀幾何對話框中重新定向參考框架。", 'tags': '', 'url': '40723121.html'}, {'title': '40723123', 'text': "建立動態形狀by40723123 \n 現在，我們將照顧關節/馬達。大多數時候，我們知道每個關節的確切位置和方向。在這種情況下，我們只需使用[菜單欄->添加->關節-> ...]添加關節，然後可以使用位置對話框和方向對話框更改它們的位置和方向。在其他情況下，我們只有Denavit-Hartenberg（即D-H）參數。在這種情況下，我們可以通過模型瀏覽器中位於Models / tools / Denavit-Hartenberg聯合creator.ttm中的工具模型來構建關節。有時，我們沒有關於關節位置和方向的信息。然後，我們需要從導入的網格中提取它們。讓我們假設這是我們的情況。無需處理修改過的，更近似的網格，而是打開一個新場景，然後再次導入原始CAD數據。大多數時候，我們可以從原始網格中提取網格或基本形狀。第一步是細分原始網格。如果那不起作用，我們將通過三角形編輯模式進行操作。假設我們可以劃分原始網格。現在，我們可以檢查較小的對象。我們正在尋找旋轉形狀，可以用作在其位置以相同方向創建關節的參考。首先，刪除所有不需要的對象。有時在多個打開的場景中工作也很有用，以便於可視化/操作。在我們的案例中，我們首先關注機器人的基座：它包含一個圓柱體，該圓柱體的第一個關節的位置正確。在三角形編輯模式下，我們有： \n Now we will take care of the joints/motors. Most of the time, we know the exact position and orientation of each of the joints. In that case, we simply add the joints with [Menu bar --> Add --> Joints --> ...], then we can change their position and orientation with the \xa0 position dialog \xa0 and \xa0 orientation dialog . In other situations, we only have the Denavit-Hartenberg (i.e. D-H) parameters. In that case, we can build our joints via the tool model located in \xa0 Models/tools/Denavit-Hartenberg joint creator.ttm , in the model browser. Othertimes, we have no information about the joint locations and orientations. Then, we need to extract them from the imported mesh. Let's suppose this is our case. Instead of working on the modified, more approximate mesh, we open a new scene, and import the original CAD data again. Most of the time, we can extract meshes or primitive shapes from the original mesh. The first step is to subdivide the original mesh. If that does not work, we do it via the \xa0 triangle edit mode . Let's suppose that we could divide the original mesh. We now have smaller objects that we can inspect. We are looking for revolute shapes, that could be used as reference to create joints at their locations, with the same orientation. First, remove all objects that are not needed. It is sometimes also useful to work across several opened scenes, for easier visualization/manipulation. In our case, we focus first on the base of the robot: it contains a cylinder that has the correct position for the first joint. In the triangle edit mode, we have: \n \n 我們通過頁面選擇器工具欄按鈕更改相機視圖，以便從側面查看對象。適合查看的工具欄按鈕可以派上用場，以正確構圖版本中的對象。然後，我們切換到頂點編輯模式，並選擇屬於上光盤的所有頂點。請記住，通過打開/關閉某些層，我們可以隱藏場景中的其他對象。然後我們切換回三角形編輯模式： \n We change the camera view via the\xa0 page selector \xa0 toolbar button , in order to look at the object from the side. The \xa0 fit-to-view toolbar button \xa0 can come in handy to correctly frame the object in edition. Then we switch to the \xa0 vertex edit mode \xa0 and select all vertices that belong to the upper disc. Remember that by switching some \xa0 layers \xa0 on/off, we can hide other objects in the scene. Then we switch back to the triangle edit mode: \n \n \n 現在，我們單擊“提取圓柱體”（在這種情況下，“提取形狀”也將起作用），這只是根據選定的三角形在場景中創建了圓柱體形狀。我們離開編輯模式並放棄更改。現在，通過[菜單欄->添加->關節->旋轉]添加旋轉關節，使其保持選中狀態，然後控制選擇提取的圓柱形狀。在位置對話框的“位置”選項卡上，單擊“應用於選擇”：這基本上將圓柱體的x / y / z位置複製到關節。現在兩個位置都相同。在方向對話框中的方向選項卡上，我們還單擊“應用於選擇”：所選對象的方向現在也相同。有時，我們將需要圍繞其自身的參考框架額外旋轉關節90/180度，以獲得正確的方向或旋轉方向。如果需要，我們可以在該對話框的“旋轉”選項卡上執行此操作（在這種情況下，請不要忘記單擊“自有框架”按鈕）。同樣，我們也可以沿關節的軸移動關節，甚至進行更複雜的操作。這就是我們所擁有的： \n Now we click\xa0 Extract cylinder \xa0 ( Extract shape \xa0 would also work in that case), this just created a cylinder shape in the scene, based on the selected triangles. We leave the edit mode and discard the changes. Now we add a revolute joint with [Menu bar --> Add --> Joint --> Revolute], keep it selected, then control-select the extracted cylinder shape. In the \xa0 position dialog , on the \xa0 position \xa0 tab, we click \xa0 Apply to selection : this basically copies the x/y/z position of the cylinder to the joint. Both positions are now identical. In the \xa0 orientation dialog , on the \xa0 orientation \xa0 tab, we also click \xa0 Apply to selection : the orientation of our selected objects is now also the same. Sometimes, we will need to additionally rotate the joint about 90/180 degrees around its own reference frame in order to obtain the correct orientation or rotation direction. We could do that on the \xa0 rotation \xa0 tab of that dialog if needed (in that case, do not forget to click the \xa0 Own frame \xa0 button). In a similar way we could also shift the joint along its axis, or even do more complex operations. This is what we have: \n \n 現在，我們將關節複製回到原始場景中，並保存它（不要忘記定期保存您的工作！撤消/重做功能很有用，但不能保護您免受其他不幸的影響）。我們對機器人中的所有關節重複上述過程，然後重命名它們。我們還將使所有關節的關節屬性稍長一些，以便查看所有關節。通過默認，關節將分配給可見性層2，但可以在對象公共屬性中對其進行更改。現在，我們將所有關節分配給可見性層10，然後為場景臨時啟用可見性層10，以使這些關節也可視化（默認情況下，僅激活場景的可見性層1-8）。這就是我們所擁有的（模型ResizableFloor_5_25模型在模型屬性對話框中暫時不可見）： \n Now we copy the joint back into our original scene, and save it (do not forget to save your work on a regular basis! The undo/redo function is useful, but doesn't protect you against other mishaps). We repeat above procedure for all the joints in our robot, then rename them. We also make all joints a little bit longer in the\xa0 joint properties , in order to see them all. By defaut, joints will be assigned to visibility layer 2, but can be changed in the \xa0 object common properties . We assign now all joints to visibility layer 10, then temporarily \xa0 enable visibility layer 10 for the scene \xa0 to also visualize those joints (by default, only visibility layers 1-8 are activated for the scene). This is what we have (the model \xa0 ResizableFloor_5_25 \xa0 was temporarily made invisible in the \xa0 model properties dialog ): \n \n 至此，我們可以開始構建模型層次結構並完成模型定義。但是，如果我們希望動態啟用opur機器人，則還有一個額外的中間步驟： \n At this point, we could start to build the model hierarchy and finish the model definition. But if we want opur robot to be \xa0 dynamically enabled , then there is an additional intermediate step: \n", 'tags': '', 'url': '40723123.html'}, {'title': '40723126', 'text': "建立動態形狀by40723126 \n If we want our robot to be dynamically enabled, i.e. react to collisions, fall, etc., then we need to create/configure the shapes appropriately: a shape can be: \n 如果我們希望我們的機器人能夠動態啟用，即對碰撞，跌落等做出反應，那麼我們需要適當地創建/配置形狀：形狀可以是： \n ◎dynamic or static: a dynamic (or non-static) shape will fall and be influences by external forces/torques. A static (or non-dynamic) shape on the other hand, will stay in place, or follow the movement of its parent in the scene hierarchy. \n ◎動態或靜態：動態（或非靜態）形狀會掉落並受到外力/扭矩的影響。 另一方面，靜態（或非動態）形狀將保持不變，或跟隨其根源在場景層次中的移動。 \n ◎respondable or non-respondable: a respondable shape will cause a collision reaction with other respondable shapes. They (and/or) their collider, will be influenced in their movement if they are dynamic. On the other hand, non-respondable shapes will not compute a collision response if they collide with other shapes. \n ◎可響應或不可響應：可響應形狀會引起與其他可響應形狀的碰撞反應。 如果它們是動態的，它們（和/或它們的對撞機）的運動將受到影響。 另一方面，不負責任的形狀如果與其他形狀發生碰撞，則不會計算碰撞響應。 \n Above two points are illustrated here. Respondable shapes should be as simple as possible, in order to allow for a fast and stable simulation. A physics engine will be able to simulate following 5 types of shapes with various degrees of speed and stability: \n 以上說明了兩點。 負責任的形狀應盡可能簡單，以實現快速穩定的仿真。 物理引擎將能夠以不同的速度和穩定性模擬以下5種類型的形狀： \n ◎Pure shapes: a pure shape will be stable and handled very efficiently by the physics engine. The draw-back is that pure shapes are limited in geometry: mostly cuboids, cylinders and spheres. If possible, use those for items that are in contact with other items for a longer time (e.g. the feet of a humanoid robot, the base of a serial manipulator, the fingers of a gripper, etc.). Pure shapes can be created with [Menu bar --> Add --> Primitive shape]. \n ◎純形狀：純形狀將穩定並由物理引擎非常有效地處理。 缺點是純形狀的幾何形狀受到限制：主要是長方體，圓柱體和球體。 如果可能的話，將其用於與其他物品接觸時間較長的物品（例如，人形機器人的腳，串行機械手的底座，抓手的手指等）。 可以使用[菜單欄->添加->基本形狀]創建純形狀。 \n ◎Pure compound shapes: a pure compound shape is a grouping of several pure shapes. It performs almost as well as pure shapes and shares similar properties. Pure compound shapes can be generated by grouping several pure shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. \n ◎純複合形狀：純複合形狀是幾個純形狀的組合。 它的性能幾乎與純形狀一樣，並具有相似的特性。 可以通過對幾個純形狀進行分組來生成純複合形狀[菜單欄->編輯->分組/合併->分組所選形狀]。 \n ◎Convex shapes: a convex shape will be a little bit less stable and take a little bit more computation time when handled by the physics engine. It allows for a more general geometry (only requirement: it need to be convex) than pure shapes. If possible, use convex shapes for items that are sporadically in contact with other items (e.g. the various links of a robot). Convex shapes can be generated with [Menu bar --> Add --> Convex hull of selection] or with [Menu bar --> Edit --> Morph selection into convex shapes]. \n ◎凸形狀：當由物理引擎處理時，凸形狀的穩定性會降低一些，而計算時間也會增加。 與純形狀相比，它允許使用更通用的幾何形狀（僅要求：它必須是凸形的）。 如果可能，將凸形用於偶爾與其他物品接觸的物品（例如，機器人的各個鏈接）。 可以使用[菜單欄->添加->選擇的凸包]或[菜單欄->編輯->將選擇變形為凸形]生成凸形。 \n ◎Compound convex shapes, or convex decomposed shapes: a convex decomposed shape is a grouping of several convex shapes. It performs almost as well as convex shapes and shares similar properties. Convex decomposed shapes can be generated by grouping several convex shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes], with [Menu bar --> Add --> Convex decomposition of selection...], or with [Menu bar --> Edit --> Morph selection into its convex decomposition...]. \n ◎複合凸形狀或凸分解形狀：凸分解形狀是幾個凸形狀的組合。 它的性能幾乎與凸形相同，並具有相似的特性。 可以通過將多個凸形分組[菜單欄->編輯->分組/合併->分組選定的形狀]，並使用[菜單欄->添加->選擇的凸分解...]來生成凸分解形狀。 ]，或使用[菜單欄->編輯->將選擇變形到其凸分解...]。 \n ◎Random shapes: a random shape is a shape that is not convex nor pure. It generally has poor performance (calculation speed and stability). Avoid using random shapes as much as possible. \n ◎隨機形狀：隨機形狀是既非凸形也不是純淨的形狀。 它通常具有較差的性能（計算速度和穩定性）。 盡量避免使用隨機形狀。 \n So the order of preference would be: pure shapes, pure compound shapes, convex shapes, compound convex shapes, and finally random shapes. Make sure to also read this page. In case of the robot we want to build, we will make the base of the robot as a pure cylinder, and the other links as convex or convex decomposed shapes. \n 因此，優先順序為：純形狀，純複合形狀，凸形，複合凸形，最後是隨機形狀。 確保還閱讀此頁面。 對於要構建的機器人，我們將其基座設為純圓柱體，將其他鏈接設為凸形或凸形分解形狀。 \n We could use the dynamically enabled shapes also as the visible parts of the robot, but that would probably not look good enough. So instead, we will build for each visible shape we have created in the first part of the tutorial a dynamically enabled counterpart, which we will keep hidden: the hidden part will represent the dynamic model and be exclusively used by the physics engine, while the visible part will be used for visualization, but also for minimum distance calculations, proximity sensor detections, etc. \n 我們也可以將動態啟用的形狀用作機器人的可見部分，但是看起來可能不夠好。 因此，相反，我們將為在本教程第一部分中創建的每個可見形狀構建一個動態啟用的副本，該副本將保持隱藏狀態：隱藏部分將代表動態模型，並由物理引擎專用，而 可見部分將用於可視化，還用於最小距離計算，接近傳感器檢測等。 \n We select object robot, copy-and-paste it into a new scene (in order to keep the original model intact) and start the triangle edit mode. If object robot was a compound shape, we would first have had to ungroup it ([Menu bar --> Edit --> Grouping/Merging --> Ungroup selected shapes]) then merge the individual shapes ([Menu bar --> Edit --> Grouping/Merging --> Merge selected shapes]) before being able to start the triangle edit mode. Now we select the few triangles that represent the power cable, and erase them. Then we select all triangles in that shape, and click Extract cylinder. We can now leave the edit mode and we have our base object represented as a pure cylinder: \n 我們選擇對像機器人，將其複制並粘貼到新場景中（以保持原始模型不變），然後啟動三角形編輯模式。 如果對像機器人是複合形狀，我們首先必須將其取消組合（[菜單欄->編輯->分組/合併->取消組合所選形狀]），然後合併各個形狀（[菜單欄-> 在啟動三角形編輯模式之前，請編輯->分組/合併->合併選定的形狀]）。 現在，我們選擇代表電源線的幾個三角形，並將其刪除。 然後，選擇該形狀中的所有三角形，然後單擊“提取圓柱體”。 現在我們可以離開編輯模式，我們的基礎對象表示為純圓柱體： \n \n [Pure cylinder generation procedure, in the triangle edit mode] \n [純圓柱體生成過程，在三角形編輯模式下] \n We rename the new shape (with a double-click on its name in the scene hierarchy) as robot_dyn, assign it to visibility layer 9, then copy it to the original scene. The rest of the links will be modelled as convex shapes, or compound convex shapes. We now select the first mobile link (i.e. object robot_link1) and generate a convex shape from it with [Menu bar --> Add --> Convex hull of selection]. We rename it to robot_link_dyn1 and assign it to visibility layer 9. When extracting the convex hull doesn't retain enough details of the original shape, then you could still manually extract several convex hulls from its composing elements, then group all the convex hulls with [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. If that appears to be problematic or time consuming, then you can automatically extract a convex decomposed shape with [Menu bar --> Add --> Convex decomposition of selection...]: \n 我們將新形狀重命名（在場景層次中雙擊其名稱）為robot_dyn，將其分配給可見性層9，然後將其複製到原始場景。 其餘鏈接將建模為凸形或複合凸形。 現在，我們選擇第一個移動鏈接（即對象robot_link1），並使用[菜單欄->添加->選擇的凸包]從中生成凸形。 我們將其重命名為robot_link_dyn1並將其分配給可見性層9。當提取凸包並沒有保留足夠的原始形狀細節時，您仍然可以手動從其組成元素中提取多個凸包，然後將所有凸包與 [菜單欄->編輯->分組/合併->對選定形狀進行分組]。 如果這似乎有問題或很耗時，則可以使用[菜單欄->添加->選擇的凸分解...]自動提取凸分解的形狀： \n \n [Original shape, and convex shape pendant] \n [原始形狀和凸形吊墜] \n \n [Original shape, and convex decomposed shape pendant] \n [原始形狀和凸形分解形狀吊墜] \n We now repeat the same procedure for all remaining robot links. Once that is done, we attach each visible shape to its corresponding invisible dynamic pendant. We do this by selecting first the visible shape, then via control-click selecting its dynamic pendant then [Menu bar --> Edit --> Make last selected object parent]. The same result can be achieved by dragging the visible shape onto its dynamic pendant in the scene hierarchy: \n 現在，我們對所有剩餘的機器人鏈接重複相同的過程。 完成後，我們將每個可見的形狀附加到其相應的不可見的動態吊墜上。 為此，我們先選擇可見的形狀，然後按住控制鍵並單擊以選擇其動態吊墜，然後選擇[菜單欄->編輯->將最後選擇的對象設為父對象]。 通過將可見形狀拖動到場景層次中的動態吊墜上，可以實現相同的結果： \n \n [Visible shapes attached to their dynamic pendants] \n [可見的形狀附加到動態吊墜上] \n We still need to take care of a few things: first, since we want the dynamic shapes only visible to the physics engine, but not to the other calculation modules, we uncheck all object special properties for the dynamic shapes, in the object common properties. \n 我們仍然需要注意一些事項：首先，由於我們希望動態形狀僅對物理引擎可見，而對其他計算模塊不可見，因此在對象通用屬性中取消選中動態形狀的所有對象特殊屬性。 \n Then, we still have to configure the dynamic shapes as dynamic and respondable. We do this in the shape dynamics properties. Select first the base dynamic shape (i.e. robot_dyn), then check the Body is respondable item. Enable the first 4 Local respondable mask flags, and disable the last 4 Local respondable mask flags: it is important for consecutive respondable links not to collide with each other. For the first mobile dynamic link in our robot (i.e. robot_link_dyn1), we also enable the Body is respondable item, but this time we disable the first 4 Local respondable mask flags, and enable the last 4 Local respondable mask flags. We repeat the above procedure with all other dynamic links, while always alternating the Local respondable mask flags: once the model will be defined, consecutive dynamic shapes of the robot will not generate any collision response when interacting with each other. Try to always end up with a construction where the dynamic base of the robot, and the dynamic last link of the robot have only the first 4 Local respondable mask flags enabled, so that we can attach the robot to a mobile platform, or attach a gripper to the last dynamic link of the robot without dynamic collision interferences. \n 然後，我們仍然必須將動態形狀配置為動態且可響應的。我們在形狀動力學屬性中執行此操作。首先選擇基本動態形狀（即robot_dyn），然後檢查“主體是可響應的”項。啟用前四個“本地可響應掩碼”標誌，並禁用後四個“本地可響應掩碼”標誌：對於連續的可響應鏈接不要彼此衝突非常重要。對於我們機器人中的第一個移動動態鏈接（即robot_link_dyn1），我們還啟用了“身體可響應”項，但是這次我們禁用了前4個“本地可響應掩碼”標誌，並啟用了後4個“本地可響應掩碼”標誌。我們對所有其他動態鏈接重複上述過程，同時始終交替使用Local Responsible Mask標誌：一旦定義了模型，則連續的機器人動態形狀在彼此交互時不會產生任何碰撞響應。嘗試始終以這樣一種構造結束：機器人的動態基礎和機器人的動態最後一個鏈接僅啟用了前4個“本地可響應掩碼”標誌，以便我們可以將機器人附加到移動平台，或附加一個抓取器連接到機器人的最後一個動態鏈接，而沒有動態碰撞干擾。 \n Finally, we still need to tag our dynamic shapes as Body is dynamic. We do this also in the shape dynamics properties. We can then enter the mass and inertia tensor properties manually, or have those values automatically computed (recommended) by clicking Compute mass & inertia properties for selected convex shapes. Remember also this and that dynamic design considerations. This dynamic base of the robot is a special case: most of the time we want the base of the robot (i.e. robot_dyn) to be non-dynamic (i.e. static), otherwise, if used alone, the robot might fall during movement. But as soon as we attach the base of the robot to a mobile platform, we want the base to become dynamic (i.e. non-static). We do this by enabling the Set to dynamic if gets parent item, then disabling the Body is dynamic item. Now run the simulation: all dynamic shapes, except for the base of the robot, should fall. That attached visual shapes will follow their dynamic pendants. \n 最後，我們仍然需要將動態形狀標記為“身體是動態的”。 我們也在形狀動力學屬性中執行此操作。 然後，我們可以手動輸入質量和慣性張量屬性，或者通過單擊“計算選定凸形的質量和慣性屬性”來自動計算（推薦）那些值。 還請記住這一點以及該動態設計注意事項。 機器人的這種動態基座是一種特殊情況：大多數時候，我們希望機器人的基座（即robot_dyn）是非動態的（即靜態），否則，如果單獨使用，則機器人可能會在運動過程中掉落。 但是，一旦我們將機器人的底座連接到移動平台上，我們就希望底座變得動態（即非靜態）。 我們通過啟用“如果獲取父項時設置為動態”項，然後禁用“主體為動態”項來做到這一點。 現在運行仿真：除了機器人的基座之外，所有動態形狀都應下降。 附加的視覺形狀將跟隨其動態吊墜。 \n", 'tags': '', 'url': '40723126.html'}, {'title': '40723108', 'text': "型號定義by40723108 \n Now we are ready to define our model. We start by building the model herarchy: we attach the last dynamic robot link ( robot_link_dyn6 ) to its corresponding joint ( robot_joint6 ) by selecting \xa0 robot_link_dyn6 , then control-selecting \xa0 robot_joint6 , then [Menu bar --> Edit --> Make last selected object parent]. We could also have done this step by simply dragging object \xa0 robot_link_dyn6 \xa0 onto \xa0 robot_link6 \xa0 in the \xa0 scene hierarchy . We go on by now attaching \xa0 robot_joint6 \xa0 to \xa0 robot_link_dyn5 , and so on, until arrived at the base of the robot. We now have following scene hierarchy: \n 現在我們準備定義模型了。我們從建立模型層次結構開始：我們先選擇最後一個動態機器人鏈接（robot_link_dyn6）與其對應的關節（robot_joint6），然後選擇[robot_link_dyn6]，然後控制選擇[robot_joint6]，然後選擇[菜單欄->編輯->創建最後一個選定對象父母]。我們也可以通過簡單地將對象robot_link_dyn6拖到場景層次結構中的robot_link6上來完成此步驟。我們現在繼續將robot_joint6附加到robot_link_dyn5上，依此類推，直到到達機器人的底部為止。現在，我們具有以下場景層次結構： \n \n It is nice and more logical to have a simple name for the model base, since the model base will also represent the model itself. So we rename \xa0 robot \xa0 to \xa0 robot_visibleBase , and \xa0 robot_dyn \xa0 to \xa0 robot . Now we select the base of the hierarchy tree (i.e. object \xa0 robot ) and in the \xa0 object common properties \xa0 we enable \xa0 Object is model base . We also enable \xa0 Object/model can transfer or accept DNA . A model bounding box appeared, encompassing the whole robot. The bounding box however appears to be too large: this is because the bounding box also encompasses the invisible items, such as the joints. We now exclude the joints from the model bounding box by enabling the \xa0 Don't show as inside model selection \xa0 item for all joints. We could do the same procedure for all invisible items in our model. This is also a useful option in order to also exclude large sensors or other items from the model bounding box. We now have following situation: \n 為模型庫起一個簡單的名字是很好而且更合乎邏輯的，因為模型庫也將代表模型本身。因此，我們將robot重命名為robot_visibleBase，並將robot_dyn重命名為robot。現在我們選擇層次結構樹的基礎（即對像機械手），並在對象公共屬性中啟用``對像是模型基礎''。我們還使對象/模型可以轉移或接受DNA。出現了一個模型包圍盒，包圍了整個機器人。但是，邊界框似乎太大：這是因為邊界框還包含不可見的項，例如關節。現在，通過對所有關節啟用“不顯示為內部模型”選擇項，將關節從模型邊界框中排除。我們可以對模型中的所有不可見項執行相同的過程。這也是一個有用的選項，可以將大型傳感器或其他項目也排除在模型邊界框之外。我們現在有以下情況： \n \n \n We now protect our model from accidental modification. We select all visible objects in the robot, then enable \xa0 Select base of model instead : if we now click a visible link in the scene, the base of the robot will be selected instead. This allows us to manipulate the model as if it was a single object. We can still select visible objects in the robot via control-shift-clicking in the scene, or by selecting the object in the scene hierarchy. We now put the robot into a correct default position/orientation. First, we save current scene as a reference (e.g. if at a later stage we need to import CAD data that have the same orientation at the curent robot). Then we select the model and \xa0 modify its position/orientation \xa0 appropriately. It is considered good practice to position the model (i.e. its base object) at X=0 and Y=0. \n 現在，我們保護模型免受意外修改。我們選擇機器人中的所有可見對象，然後啟用“選擇模型的基礎”：如果現在單擊場景中的可見鏈接，則會改為選擇機器人的基礎。這使我們可以像對待單個對像一樣操作模型。我們仍然可以通過按住Shift鍵並單擊場景或在場景層次中選擇對象來選擇機器人中的可見對象。現在，我們將機器人置於正確的默認位置/方向。首先，我們將當前場景保存為參考（例如，如果稍後需要在當前機器人上導入方向相同的CAD數據）。然後，我們選擇模型並適當修改其位置/方向。將模型（即其基礎對象）定位在X = 0和Y = 0處被認為是一種好習慣。 \n \n We now run the simulation: the robot will collapse, since the joints are not controlled by default. \xa0 When we added the joints in the previous stage , we created joints in force/torque mode, but their motor or controller was disabled (by default). We can now adjust our joints to our requirements. In our case, we want a simple PID controller for each one of them. In the joint dynamic properties, we click \xa0 Motor enabled \xa0 and adjust the \xa0 maximum torque . We then click \xa0 Control loop enabled \xa0 and select \xa0 Position control (PID) . We now run the simulation again: the robot should hold its position. Try to switch the current physics engine to see if the behaviour is consistent across all supported physics engines. You can do this via the appropriate \xa0 toolbar button , or in the \xa0 general dynamics properties . \n 現在我們運行模擬：由於默認情況下關節不受控制，因此機器人將崩潰。在上一階段添加關節時，我們以力/扭矩模式創建了關節，但其電動機或控制器已禁用（默認情況下）。現在，我們可以根據需要調整關節。在我們的案例中，我們希望為每個控制器都提供一個簡單的PID控制器。在關節動態屬性中，單擊“啟用電機”並調整最大扭矩。然後，單擊啟用控制環，然後選擇位置控制（PID）。現在，我們再次運行仿真：機器人應保持其位置。嘗試切換當前的物理引擎，以查看行為在所有受支持的物理引擎之間是否一致。您可以通過相應的工具欄按鈕或在常規動力學屬性中執行此操作。 \n During simulation, we now verify the scene dynamic content via the \xa0 Dynamic content visualization & verification toolbar button . Now, only items that are taken into account by the physics engine will be display, and the display is \xa0 color-coded . It is \xa0 very important \xa0 to always do this, and specially when your dynamic model doesn't behave as expected, in order to quickly debug the model. Similarly, always look at the scene hierarchy during simulation: dynamically enabled objects should display a ball-bounding icon on the right-hand side of their name. \n 在仿真過程中，我們現在通過“動態內容可視化和驗證”工具欄按鈕來驗證場景動態內容。現在，將僅顯示物理引擎考慮的項目，並且該顯示使用顏色編碼。始終執行此操作非常重要，尤其是在動態模型無法按預期運行時，為了快速調試模型，尤其如此。同樣，在仿真過程中請始終查看場景層次：動態啟用的對象應在其名稱的右側顯示一個球形圖標。 \n \n \n Finally, we need to prepare the robot so that we can easily attach a gripper to it, or easily attach the robot to a mobile platform (for instance). Two dynamically enabled shapes can be rigidly attached to each other in two different ways: \n 最後，我們需要準備機器人，以便我們可以輕鬆地將抓取器連接到它，或輕鬆地將機器人連接到移動平台（例如）。可以通過兩種不同的方式將兩個動態啟用的形狀嚴格地彼此附加： \n \n by grouping them : select the shapes, then [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. \n 通過對它們進行分組：選擇形狀，然後選擇[菜單欄->編輯->分組/合併->對選定形狀進行分組]。 \n by attaching them via a force/torque sensor : a \xa0 force torque sensor \xa0 can also act as a rigid link between two separate dynamically enabled shapes. \n 通過通過力/扭矩傳感器進行連接：力扭矩傳感器還可以充當兩個單獨的動態啟用形狀之間的剛性鏈接。 \n \n In our case, only option 2 is of interest. We create a force/torque sensor with [Menu bar --> Add --> Force sensor], then move it to the tip of the robot, then attach it to object \xa0 robot_link_dyn6 . We change its size and visual appearance appropriately (a red force/torque sensor is often perceived as an optional attachment point, check the various robot models available). We also change its name to \xa0 robot_attachment : \n 在我們的情況下，只有選項2是有意義的。我們使用[菜單欄->添加->力傳感器]創建一個力/扭矩傳感器，然後將其移動到機器人的尖端，然後將其附加到對象robot_link_dyn6。我們會適當地更改其尺寸和外觀（紅色力/扭矩傳感器通常被視為可選的連接點，請檢查可用的各種機器人型號）。我們還將其名稱更改為robot_attachment： \n \n Now we drag a gripper model into the scene, keep it selected, then control-click the attachment force sensor, then click the \xa0 Assembling/disassembling toolbar button . The gripper goes into place: \n 現在，我們將抓手模型拖到場景中，使其保持選中狀態，然後按住Control鍵單擊並單擊附著力傳感器，然後單擊“裝配/拆卸”工具欄按鈕。夾持器到位： \n \n The gripper knew how to attach itself because it was appropriately configured during its model definition. We now also need to properly configure the robot model, so that it will know how to attach itself to a mobile base for instance. We select the robot model, then click \xa0 Assembling \xa0 in the \xa0 object common properties . Set an empty string for \xa0 'Parent' match values , then click \xa0 Set matrix . This will memorize the current base object's local transformation matrix, and use it to position/orient itself relative to the mobile robot's attachment point. To verify that we did things right, we drag the model \xa0 Models/robots/mobile/KUKA Omnirob.ttm \xa0 into the scene. Then we select our robot model, then control-click one of the attachment points on the mobile platform, then click the \xa0 Assembling/disassembling toolbar button . Our robot should correctly place itself on top of the mobile robot: \n 抓具知道如何附加自身，因為它在模型定義期間進行了適當的配置。現在，我們還需要正確配置機器人模型，以便它將知道如何將自己附加到移動基座上。我們選擇機器人模型，然後在對象公共屬性中單擊“組裝”。為“父項”匹配值設置一個空字符串，然後單擊“設置矩陣”。這將記住當前基礎對象的局部轉換矩陣，並使用它相對於移動機器人的附著點定位/定向。為了驗證我們做的正確，我們將模型Models / robots / mobile / KUKA Omnirob.ttm拖到場景中。然後，我們選擇機器人模型，然後在移動平台上按住Control鍵並單擊其中一個附接點，然後單擊“組裝/拆卸”工具欄按鈕。我們的機器人應該正確地將自己放置在移動機器人的頂部： \n \n Now we could add additional items to our robot, such as sensors for instance. At some point we might also want to attach \xa0 embedded scripts \xa0 to our model, in order to control its behaviour or configure it for various purposes. In that case, make sure to understand \xa0 how object handles are accessed from embedded scripts . We can also control/access/interface our model from a \xa0 plugin , from a \xa0 remote API \xa0 client, from a \xa0 ROS \xa0 node, from a \xa0 BlueZero \xa0 node, or from an \xa0 add-on . \n 現在，我們可以向機器人添加其他項目，例如傳感器。在某些時候，我們可能還希望將嵌入式腳本附加到我們的模型中，以便控制其行為或出於各種目的對其進行配置。在這種情況下，請確保了解如何從嵌入式腳本訪問對象句柄。我們還可以通過插件，遠程API客戶端，ROS節點，BlueZero節點或附加組件來控制/訪問/接口模型。 \n Now we make sure we have reverted the changes done during robot and gripper attachment, we collapse the hierarchy tree of our robot model, select the base of our model, then save it with [Menu bar --> File --> Save model as...]. If we saved it in the \xa0 model \xa0 folder, then the model will be available in the \xa0 model brower . \n 現在，確保已恢復在機械手和抓爪安裝過程中所做的更改，我們折疊了機械手模型的層次樹，選擇了模型的基礎，然後使用[菜單欄->文件->將模型另存為...]。如果我們將其保存在模型文件夾中，則模型將在模型瀏覽器中可用。 \n \xa0 \n \n", 'tags': '', 'url': '40723108.html'}, {'title': 'Webots User Guide', 'text': '', 'tags': '', 'url': 'Webots User Guide.html'}, {'title': '40723104', 'text': '', 'tags': '', 'url': '40723104.html'}, {'title': '40723130', 'text': 'Geometries \n To define the ball, we used the Sphere node in two different contexts: for the graphical representation (children) and to define the physical bounds (boundingObject). All Geometry nodes (such as the Sphere node) can be used in a graphical context. However, only a subset of them can be used in a physical context. The nodes chart diagram indicates which nodes are supported in each context. \n We are now going to reduce the size of the Sphere and increase its graphical quality by increasing the number of triangles used to represent it. \n 幾何形狀 \n 為了定義球，我們在兩個不同的上下文中使用了Sphere節點：用於圖形表示（children）和定義物理邊界（boundingObject）。 所有Geometry節點（例如Sphere節點）都可以在圖形上下文中使用。 但是，它們的子集只能在物理環境中使用。 節點圖表顯示了每個上下文中支持哪些節點。 \n \xa0 \n 現在，我們將通過增加用來表示球體三角形的數量來減小球體的大小並提高其圖形質量。 \n Hands-on #5: For each Sphere node defining the ball, set its radius field to 0.05 and its subdivision field to 2. Refer to the Reference Manual to understand what the subdivision field stands for. \n \xa0 \n 動手操作5：對於定義球的每個Sphere節點，將其半徑字段設置為0.05，並將其細分字段設置為2。請參閱《參考手冊》以了解細分字段的含義。 \n \xa0 \n DEF-USE Mechanism \n The DEF-USE mechanism allows to define a node in one place and to reuse that definition elsewhere in the scene tree. This is useful to avoid the duplication of identical nodes in world files. Moreover, it also allows users to modify several objects at the same time. Here is how it works: first a node is labeled with a DEF string. Then copies of this node can be reused elsewhere with the USE keyword. Only the fields of the DEF node can be edited, the fields of the USE inherit from the DEF node and cannot be changed. This mechanism is dependent on the order of the nodes in the world file. A DEF node should be defined before any corresponding USE node. \n The two Sphere definitions that we have used earlier to define the ball, are redundant. We will now merge these two Spheres into only once using the DEF-USE mechanism. \n \xa0 \n DEF-USE機制 \n DEF-USE機制允許在一個位置定義節點，並在場景樹的其他位置重用該定義。 這對於避免在世界文件中復制相同節點很有用。 此外，它還允許用戶同時修改多個對象。 它是這樣工作的：首先用DEF字符串標記節點。 然後，可以使用USE關鍵字將該節點的副本重用於其他地方。 只能編輯DEF節點的字段，USE的字段從DEF節點繼承，並且不能更改。 該機制取決於world文件中節點的順序。 應在任何相應的USE節點之前定義DEF節點。 \n \xa0 \n Hands-on #6: Select the first Sphere node (the child of the Shape) in the scene tree view. The field editor of the scene tree view allows you to enter the DEF string. \n \xa0 \n Enter BALL_GEOMETRY in this field. \n Select the boundingObject field (containing the second Sphere node), and empty it by right clicking the field in the scene tree and choosing the Delete entry in the context menu that pops up. \n Then, select the boundingObject field and click on the Add button, and select the USE / BALL_GEOMETRY in the dialog box. \n The result is shown in this figure. \n \xa0 \n 動手操作6：在場景樹視圖中選擇第一個Sphere節點（Shape的子級）。 場景樹視圖的字段編輯器允許您輸入DEF字符串。 \n \xa0 \n 在此字段中輸入BALL_GEOMETRY。 \n 選擇boundingObject字段（包含第二個Sphere節點），並通過右鍵單擊場景樹中的字段並在彈出的上下文菜單中選擇“刪除”條目來將其清空。 \n 然後，選擇boundingObject字段，然後單擊“添加”按鈕，然後在對話框中選擇USE / BALL_GEOMETRY。 \n 結果如圖所示。 \n \xa0 \n \xa0 \n Now, changing the radius field of the first Sphere node also modifies its boundingObject. \n \xa0 \n For convenience, the boundingObject field accepts also the Shape node (rather than the Sphere node directly). It would be also possible to use the same DEF-USE mechanism at the Shape level as shown in this figure. For now the greatest benefit is being able to also use this Shape directly for graphical purposes. Later this mechanism will turn out to be very useful for some sensors. \n \xa0 \n .現在，更改第一個Sphere節點的半徑字段也會修改其boundingObject。 \n \xa0 \n 為了方便起見，boundingObject字段還接受Shape節點（而不是直接接受Sphere節點）。 如圖所示，也可以在Shape級別使用相同的DEF-USE機制。 到目前為止，最大的好處就是也可以直接將此Shape用於圖形目的。 後來，對於某些傳感器，該機制將變得非常有用。 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n DEF-USE mechanism on the Sphere node called BALL_GEOMETRY \n Sphere節點上的DEF-USE機制稱為BALL_GEOMETRY。 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n DEF-USE mechanism applied on the Shape node of a Solid. \n 在實體的“形狀”節點上應用的DEF-USE機制。 \n Hands-on #7: Create a second ball with the same parameters but using the Shape node (rather than the Sphere node directly) for the DEF-USE mechanism. \n \xa0 \n 動手練習7：使用DEF-USE機制的Shape節點（而不是直接使用Sphere節點）創建具有相同參數的第二個球。 \n \xa0 \n Add Walls \n In order to verify your progression, implement by yourself four walls to surround the environment. The walls have to be defined statically to the environment. To understand the difference between static and dynamic, let\'s take a defined object (the ball) above the ground. If the Physics node is NULL, it will remain frozen in the air during the simulation (static case). If the physics field contains a Physics nodes, it will fall under the effect of gravity (dynamic case). \n \xa0 \n Use as much as possible the DEF-USE mechanism at the Shape level rather than at the Geometry level. Indeed it\'s more convenient to add an intermediate Shape node in the boundingObject field of the Solid node. The best Geometry primitive to implement the walls is the Box node. Only one Shape has to be defined for all the walls. The expected result is shown in this figure. \n \xa0 \n 添加牆 \n 為了驗證您的進度，請自己實施四堵牆以包圍環境。 必須根據環境靜態定義牆壁。 要了解靜態和動態之間的區別，我們將定義的物體（球）放在地面上方。 如果“物理”節點為NULL，則在仿真過程中它將保持凍結狀態（靜態情況）。 如果物理場包含“物理”節點，則它將受重力作用（動態情況）。 \n \xa0 \n 在Shape級別而不是Geometry級別，盡可能使用DEF-USE機制。 實際上，在Solid節點的boundingObject字段中添加中間Shape節點更為方便。 實現牆的最佳幾何原語是Box節點。 所有牆壁僅需定義一個形狀。 預期結果如圖所示。 \n \xa0 \n Hands-on #8: Add four walls without physics and using only one definition of the Shape node. \n \xa0 \n 實際操作＃8：添加四面牆，無需物理操作，僅使用“形狀”節點來定義。 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n Solution: World File \n To compare your world with the solution, go to your files and find the folder named "my_first_simulation" created in Tutorial 1, then go to the "worlds" folder and open with a text editor the right world. This solution as the others is located in the solution directory. \n \xa0 \n 解決方案：世界文件 \n 要將您的world與解決方案進行比較，請轉到文件，找到在教程1中創建的名為“ my_first_simulation”的文件夾，然後轉到“ worlds”文件夾，並使用文本編輯器打開正確的world。 與其他解決方案一樣，該解決方案位於解決方案目錄中。 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n \xa0 \n The simulation state at the end of this second tutorial. \n 在第二篇教程結尾處的仿真狀態。 \n \xa0 \n Efficiency \n The simulation of rigid bodies is computationally expensive. The simulation speed can be increased by minimizing the number of bounding objects, minimizing the constraints between them (more information about the constraints in the next tutorials), and maximizing the WorldInfo.basicTimeStep field. On each simulation, a trade-off has to be found between simulation speed and realism. \n \xa0 \n 效率 \n 剛體的模擬在計算上是昂貴的。 可以通過以下方法來提高仿真速度：最小化邊界對象的數量，最小化邊界對象之間的約束（有關下一個教程的約束的更多信息），並最大化WorldInfo.basicTimeStep字段。 在每個模擬中，必須在模擬速度和真實性之間找到一個折衷。 \n \xa0 \n Conclusion \n At the end of this tutorial, you are able to create simple environments based on rigid bodies. You are able to add nodes from the scene tree view and to modify their fields. You have become acquainted with the Solid, Physics, Shape, Sphere and Box nodes. You also saw the DEF-USE mechanism that allows to reduce node redundancy of the scene tree. \n \xa0 \n 結論 \n 在本教程的最後，您將能夠基於剛體創建簡單的環境。 您可以從場景樹視圖添加節點並修改其字段。 您已經熟悉了“實體”，“物理”，“形狀”，“球體”和“盒子”節點。 您還看到了DEF-USE機制，該機制可減少場景樹的節點冗餘。 \n', 'tags': '', 'url': '40723130.html'}]};